<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- This document describes OpenScop, a specification of a file format and a set
of data structures for polyhedral compilation tools to talk
together. It also describes briefly the OpenScop Library version 0.9.0, 
a Free Software that provides an example of OpenScop implementation.

It would be quite kind to refer at the present document in any publication that
results from the use of the OpenScop Library:

@TechReport{Bas11,
  author =      {C\'edric Bastoul},
  title =       {OpenScop: A Specification and a Library for Data 
                 Exchange in Polyhedral Compilation Tools},
  month =       {September},
  year =        2011,
  institution = {Paris-Sud University, France}
}

Copyright (C) 2011 Paris-Sud University and INRIA.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 published by the
Free Software Foundation; with no Invariant Sections, with no Front-Cover
Texts, and with no Back-Cover Texts. To receive a copy of the
GNU Free Documentation License, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA  02111-1307 USA. -->
<!-- Created by GNU Texinfo 6.7, http://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>OpenScop Specification and Library</title>

<meta name="description" content="OpenScop Specification and Library">
<meta name="keywords" content="OpenScop Specification and Library">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<h1 class="settitle" align="center">OpenScop Specification and Library</h1>







<span id="SEC_Contents"></span>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a id="toc-Introduction-1" href="#Introduction">1 Introduction</a></li>
  <li><a id="toc-Polyhedral-Representation-of-Programs" href="#Polyhedral-Representation">2 Polyhedral Representation of Programs</a>
  <ul class="no-bullet">
    <li><a id="toc-Motivation_003a-Program-Transformations" href="#Motivation">2.1 Motivation: Program Transformations</a></li>
    <li><a id="toc-Thinking-in-Polyhedra-1" href="#Thinking-in-Polyhedra">2.2 Thinking in Polyhedra</a>
    <ul class="no-bullet">
      <li><a id="toc-Iteration-Domain-1" href="#Iteration-Domain">2.2.1 Iteration Domain</a></li>
      <li><a id="toc-Scattering-Function-1" href="#Scattering-Function">2.2.2 Scattering Function</a></li>
      <li><a id="toc-Access-Function-1" href="#Access-Function">2.2.3 Access Function</a></li>
    </ul></li>
    <li><a id="toc-What_0027s-Next_003f-1" href="#What_0027s-Next_003f">2.3 What&rsquo;s Next?</a></li>
  </ul></li>
  <li><a id="toc-OpenScop-Specification-1" href="#OpenScop-Specification">3 OpenScop Specification</a>
  <ul class="no-bullet">
    <li><a id="toc-Preliminary-Example-1" href="#Preliminary-Example">3.1 Preliminary Example</a></li>
    <li><a id="toc-OpenScop-File-Format-Specification-1" href="#OpenScop-File-Format-Specification">3.2 OpenScop File Format Specification</a>
    <ul class="no-bullet">
      <li><a id="toc-Relations-1" href="#Relations">3.2.1 Relations</a>
      <ul class="no-bullet">
        <li><a id="toc-Iteration-Domain-Relation-1" href="#Iteration-Domain-Relation">3.2.1.1 Iteration Domain Relation</a></li>
        <li><a id="toc-Context-Domain-Relation-1" href="#Context-Domain-Relation">3.2.1.2 Context Domain Relation</a></li>
        <li><a id="toc-Scattering-Relation-1" href="#Scattering-Relation">3.2.1.3 Scattering Relation</a></li>
        <li><a id="toc-Access-Relation-1" href="#Access-Relation">3.2.1.4 Access Relation</a></li>
      </ul></li>
      <li><a id="toc-Generics-1" href="#Generics">3.2.2 Generics</a>
      <ul class="no-bullet">
        <li><a id="toc-Strings-Generic-1" href="#Strings-Generic">3.2.2.1 Strings Generic</a></li>
        <li><a id="toc-Body-Generic-1" href="#Body-Generic">3.2.2.2 Body Generic</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-OpenScop-Data-Structure-Specification-1" href="#OpenScop-Data-Structure-Specification">3.3 OpenScop Data Structure Specification</a>
    <ul class="no-bullet">
      <li><a id="toc-osl_005fint_005ft-1" href="#osl_005fint_005ft">3.3.1 osl_int_t</a></li>
      <li><a id="toc-osl_005frelation_005ft-1" href="#osl_005frelation_005ft">3.3.2 osl_relation_t</a></li>
      <li><a id="toc-osl_005frelation_005flist_005ft-1" href="#osl_005frelation_005flist_005ft">3.3.3 osl_relation_list_t</a></li>
      <li><a id="toc-osl_005finterface_005ft-1" href="#osl_005finterface_005ft">3.3.4 osl_interface_t</a></li>
      <li><a id="toc-osl_005fgeneric_005ft-1" href="#osl_005fgeneric_005ft">3.3.5 osl_generic_t</a></li>
      <li><a id="toc-osl_005fstrings_005ft-1" href="#osl_005fstrings_005ft">3.3.6 osl_strings_t</a></li>
      <li><a id="toc-osl_005fbody_005ft-1" href="#osl_005fbody_005ft">3.3.7 osl_body_t</a></li>
      <li><a id="toc-osl_005fstatement_005ft-1" href="#osl_005fstatement_005ft">3.3.8 osl_statement_t</a></li>
      <li><a id="toc-osl_005fscop_005ft-1" href="#osl_005fscop_005ft">3.3.9 osl_scop_t</a></li>
    </ul></li>
    <li><a id="toc-Extensions-1" href="#Extensions">3.4 Extensions</a>
    <ul class="no-bullet">
      <li><a id="toc-Comment-Extension-1" href="#Comment-Extension">3.4.1 Comment Extension</a></li>
      <li><a id="toc-Scatnames-Extension-1" href="#Scatnames-Extension">3.4.2 Scatnames Extension</a></li>
      <li><a id="toc-Arrays-Extension-1" href="#Arrays-Extension">3.4.3 Arrays Extension</a></li>
      <li><a id="toc-Coordinates-Extension-1" href="#Coordinates-Extension">3.4.4 Coordinates Extension</a></li>
      <li><a id="toc-Clay-Extension-1" href="#Clay-Extension">3.4.5 Clay Extension</a></li>
      <li><a id="toc-Extbody-Extension-1" href="#Extbody-Extension">3.4.6 Extbody Extension</a></li>
      <li><a id="toc-Loop-Extension-1" href="#Loop-Extension">3.4.7 Loop Extension</a></li>
      <li><a id="toc-Pluto-unroll-Extension-1" href="#Pluto-unroll-Extension">3.4.8 Pluto unroll Extension</a></li>
      <li><a id="toc-Irregular-Extension-1" href="#Irregular-Extension">3.4.9 Irregular Extension</a></li>
    </ul></li>
    <li><a id="toc-History-1" href="#History">3.5 History</a></li>
  </ul></li>
  <li><a id="toc-OpenScop-Library-1" href="#OpenScop-Library">4 OpenScop Library</a>
  <ul class="no-bullet">
    <li><a id="toc-Precision-1" href="#Precision">4.1 Precision</a></li>
    <li><a id="toc-Base-Functions-1" href="#Base-Functions">4.2 Base Functions</a>
    <ul class="no-bullet">
      <li><a id="toc-Dumping_003a-osl_005fstructure_005fdump-and-idump" href="#Dumping">4.2.1 Dumping: osl_<em>structure</em>_dump and idump</a></li>
      <li><a id="toc-Printing_003a-osl_005fstructure_005fprint" href="#Printing">4.2.2 Printing: osl_<em>structure</em>_print</a></li>
      <li><a id="toc-Reading_003a-osl_005fstructure_005fread" href="#Reading">4.2.3 Reading: osl_<em>structure</em>_read</a></li>
      <li><a id="toc-Allocating_003a-osl_005fstructure_005fmalloc" href="#Allocating">4.2.4 Allocating: osl_<em>structure</em>_malloc</a></li>
      <li><a id="toc-Deallocating_003a-osl_005fstructure_005ffree" href="#Deallocating">4.2.5 Deallocating: osl_<em>structure</em>_free</a></li>
      <li><a id="toc-Cloning_003a-osl_005fstructure_005fclone" href="#Cloning">4.2.6 Cloning: osl_<em>structure</em>_clone</a></li>
      <li><a id="toc-Testing_003a-osl_005fstructure_005fequal" href="#Testing">4.2.7 Testing: osl_<em>structure</em>_equal</a></li>
    </ul></li>
    <li><a id="toc-Example-of-OpenScop-Library-Utilization-1" href="#Example-of-OpenScop-Library-Utilization">4.3 Example of OpenScop Library Utilization</a></li>
    <li><a id="toc-Installation-1" href="#Installation">4.4 Installation</a>
    <ul class="no-bullet">
      <li><a id="toc-License-1" href="#License">4.4.1 License</a></li>
      <li><a id="toc-Requirements-1" href="#Requirements">4.4.2 Requirements</a>
      <ul class="no-bullet">
        <li><a id="toc-GMP-Library-_0028optional_0029" href="#GMP-Library">4.4.2.1 GMP Library (optional)</a></li>
      </ul></li>
      <li><a id="toc-Installation-Instructions-1" href="#Installation-Instructions">4.4.3 Installation Instructions</a></li>
      <li><a id="toc-Optional-Features-1" href="#Optional-Features">4.4.4 Optional Features</a></li>
      <li><a id="toc-Uninstallation-1" href="#Uninstallation">4.4.5 Uninstallation</a></li>
    </ul></li>
    <li><a id="toc-Documentation-1" href="#Documentation">4.5 Documentation</a></li>
    <li><a id="toc-Development-1" href="#Development">4.6 Development</a>
    <ul class="no-bullet">
      <li><a id="toc-Copyright-Issue-1" href="#Copyright-Issue">4.6.1 Copyright Issue</a></li>
      <li><a id="toc-Repository-1" href="#Repository">4.6.2 Repository</a></li>
      <li><a id="toc-Coding-Style-1" href="#Coding-Style">4.6.3 Coding Style</a></li>
      <li><a id="toc-Extension-Development-1" href="#Extension-Development">4.6.4 Extension Development</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-References-1" href="#References">5 References</a></li>
</ul>
</div>


<span id="Top"></span><div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="OpenSCop"></span><h1 class="top">OpenSCop</h1>

<p>This document describes OpenScop, a specification of a file format and a set
of data structures for polyhedral compilation tools to talk
together. It also describes briefly the OpenScop Library version 0.9.0, 
a Free Software that provides an example of OpenScop implementation.
</p>
<p>It would be quite kind to refer at the present document in any publication that
results from the use of the OpenScop Library:
</p>
<div class="example">
<pre class="example">@TechReport{Bas11,
&nbsp;&nbsp;author =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{C\'edric Bastoul},
&nbsp;&nbsp;title =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{OpenScop: A Specification and a Library for Data 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exchange in Polyhedral Compilation Tools},
&nbsp;&nbsp;month =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{September},
&nbsp;&nbsp;year =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2011,
&nbsp;&nbsp;institution = {Paris-Sud University, France}
}
</pre></div>

<p>Copyright &copy; 2011 Paris-Sud University and INRIA.
</p>
<p>Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 published by the
Free Software Foundation; with no Invariant Sections, with no Front-Cover
Texts, and with no Back-Cover Texts. To receive a copy of the
GNU Free Documentation License, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA  02111-1307 USA.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Polyhedral-Representation" accesskey="2">Polyhedral Representation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenScop-Specification" accesskey="3">OpenScop Specification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenScop-Library" accesskey="4">OpenScop Library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#References" accesskey="5">References</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<span id="Introduction"></span><div class="header">
<p>
Next: <a href="#Polyhedral-Representation" accesskey="n" rel="next">Polyhedral Representation</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Introduction-1"></span><h2 class="chapter">1 Introduction</h2>
<p>OpenScop is an open specification that defines a file format and a set of
data structures to represent a <em>static control part</em> (SCoP for short),
i.e., a program part that can be represented in the <em>polyhedral model</em>.
The goal of OpenScop is to provide a common interface to various
polyhedral compilation tools in order to simplify their interaction. 
</p>
<p>Designing a single format for tools that have different purposes
(e.g., as different as code generation and data dependence analysis) may
sound strange at first. However we could observe that most available
polyhedral compilation tools during the last decade were manipulating
more or less the same kind of data (polyhedra, affine functions...) and
were actually sharing a part of their input (e.g., iteration domains and
context concepts are nearly everywhere). We could also observe that
those tools may rely on different internal representations, mostly based on
one of the major polyhedral libraries (e.g., Polylib, PPL or isl), and
this representation may change over time (e.g., when switching to a
more convenient polyhedral library).
The OpenScop aim is to provide a stable, unified format that offers a
durable guarantee that a tool can use an output or provide an input to
another tool without breaking a tool chain because of some internal
changes in one element of the chain. The other promise of OpenScop is
the ability to assemble or replace the basic blocks of a polyhedral
compilation framework at no, or at least low engineering cost.
</p>
<p>The policy that drives OpenScop can be summarized by these three rules:
</p><ul>
<li> Embed the <em>minimum</em> information to build a complete polyhedral
       compilation framework in the so-called <em>core part</em>
       (to avoid as much as possible empty or useless information
       for each tool).
</li><li> Provide a <em>very stable</em> core part (so users have some
       guarantee that they will not need to update their tool
       because of frequent specification evolution),
</li><li> Provide a <em>very flexible</em> extension part (so it can also
       be used to test wild new ideas).
</li></ul>

<p>Another, more technical, rule may be added:
</p><ul>
<li> Avoid any need for external library or tool to support it
       (i.e., it&rsquo;s not XML or YAML or anything like that).
</li></ul>

<p>The success of OpenScop in meeting its goals totally depends on its
acceptance by the tool developers (that have to support it in their tools).
To help them, we provide an example implementation: the OpenScop Library.
This library (and in particular its API) is not part of the OpenScop
specification (which includes only the file format and the set of data
structures). It is licensed under the 3-clause BSD license so developers may
feel free to use it in their code (either by linking it or copy-pasting its
code). This document also describes this library briefly (readers are
invited to read at its technical documentation).
The current version of the OpenScop Library is still under evaluation,
and there is no guarantee that the upward compatibility will be respected,
even if we do think so. A lot of reports are
necessary to freeze the library API. Thus you are very welcome and
encouraged to send reports on bugs, wishes, critics, comments, suggestions
or (please!) successful experiences to the OpenScop mailing list
<a href="mailto:openscop-development@googlegroups.com">openscop-development@googlegroups.com</a>.
</p>
<p>This document is organized as follows. First, we provide some
background on the polyhedral model and how it is used to represent and to
manipulate programs (see <a href="#Polyhedral-Representation">Polyhedral Representation</a>). Next,
we describe the OpenScop specification, from the file format
(see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>) to the data structures
and the OpenScop Library API
(see <a href="#OpenScop-Data-Structure-Specification">OpenScop Data Structure Specification</a>).
Finally we will detail how to install the OpenScop Library
(see <a href="#Installation">Installation</a>).
</p>

<hr>
<span id="Polyhedral-Representation"></span><div class="header">
<p>
Next: <a href="#OpenScop-Specification" accesskey="n" rel="next">OpenScop Specification</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Polyhedral-Representation-of-Programs"></span><h2 class="chapter">2 Polyhedral Representation of Programs</h2>
<p>If you are reading at the OpenScop documentation, you probably don&rsquo;t need any
explanation about the polyhedral model. It is unlikely that someone will read
this paper by mistake. However some vicious advisor may ask their poor
engineers/interns/students
to work for the very first time on this exciting topic. Most papers on
polyhedral compilation are hard to read. Despite my efforts,
mine are no exception according to some reviewers. Hence I give there a new
try to provide a comprehensive explanation of the polyhedral model without the
size and style limits of a classical research paper.
</p>
<p>Be aware that to be able to understand the polyhedral model, there are a few
prerequisites. You should not read the following while you still ignore
what is:
</p><ul>
<li> a <code>for</code> loop construction in C programs (<code>do</code> loops in FORTRAN are OK too!),
</li><li> an <em>affine expression</em>,
</li><li> a <em>vector</em>,
</li><li> a <em>matrix</em>,
</li><li> a <em>matrix-vector multiply</em>.
</li></ul>
<p>If you do not know those concepts, please do some search and come back
afterwards. And if you are courageous enough, send me a few lines that
describe them so I can insert them here!
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Motivation" accesskey="1">Motivation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Thinking-in-Polyhedra" accesskey="2">Thinking in Polyhedra</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#What_0027s-Next_003f" accesskey="3">What's Next?</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<span id="Motivation"></span><div class="header">
<p>
Next: <a href="#Thinking-in-Polyhedra" accesskey="n" rel="next">Thinking in Polyhedra</a>, Up: <a href="#Polyhedral-Representation" accesskey="u" rel="up">Polyhedral Representation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Motivation_003a-Program-Transformations"></span><h3 class="section">2.1 Motivation: Program Transformations</h3>

<p>A direct translation of high level programs written, e.g., in C, to assembly
then to object code is likely to produce (very) inefficient applications.
Architectures are
quite complex, including several levels of cache memory, many cores, deep
pipelines, various number of functional units, of registers etc.
The list of such
&quot;architectural features&quot; is growing with each new generation of processors.
To achieve the best performance, the object program must use
these features in a smart way.
Programmers use high level languages for productivity and portability:
typically they do not have to take care of the target architecture but
to ensure they write programs which produce the right output. Hence,
the problem of mapping the program to the target architecture in the most
efficient way is left to the compiler.
</p>
<p>The compiler may see a high level program as a specification
<em>of an output</em>. The program is a list of instructions to be executed to
produce the output. As long as the output is guaranteed to be as the
programmer specified in his code, the compiler is free to modify
the program.
For instance, let us imagine we are working on an architecture with only
three registers and we consider the following statements written by
a programmer:
</p>
<div class="example">
<pre class="example">x = a + b;
y = c + d;
z = a * b;
</pre></div>

<p>It is easy to see that we can reorder the three statements in any way without
modifying the semantics (no statement reads or writes a variable that another
statement writes). Because of the lack of registers, the solutions such that
the first and the third statements are one after the other are better
because <code>a</code> and <code>b</code> will be put in the processor registers by
one statement and can be reused directly by the other one
without reading from memory (this is called a <em>data locality
improving</em> transformation). Hence a better statement order is, e.g.:
</p>
<div class="example">
<pre class="example">x = a + b;
z = a * b; // a and b are still in processor registers
y = c + d;
</pre></div>

<p>We can also notice that it is possible to run the three statements in
parallel (possibly on different processors). The programmer may
explicit this in a way the compiler
and/or the architecture is able to understand. For instance,
we can use OpenMP to describe parallelism
(this is called a <em>parallelizing</em> transformation):
</p>
<div class="example">
<pre class="example">#pragma omp parallel sections
{
   #pragma omp section
   {
     x = a + b;
   }
   #pragma omp section
   {
     y = c + d;
   }
   #pragma omp section
   {
     z = a * b;
   }
}
</pre></div>

<p>However, the right way to optimize this program is probably a tradeoff
between these two techniques. This is true if, e.g., the target
architecture has some limitations to run too many operations in parallel,
or, like in our case, when some data may be reused by some processors.
Hence, the best optimization for our small example is probably the
following:
</p>
<div class="example">
<pre class="example">#pragma omp parallel sections
{
   #pragma omp section
   {
     x = a + b;
     z = a * b;
   }
   #pragma omp section
   {
     y = c + d;
   }
}
</pre></div>

<p>This example is quite trivial because the statements are
executed only once. The real sport begins when we have to deal with loops,
as we will see momentarily. However, polyhedral compilation framework users
have to be conscious that we <em>need</em> to transform programs to achieve
the best performance and that the best transformation  that has to be
discovered (at the price of many, many efforts) and performed may be
quite complex. Hence the need of powerful model and tools.
</p>

<hr>
<span id="Thinking-in-Polyhedra"></span><div class="header">
<p>
Next: <a href="#What_0027s-Next_003f" accesskey="n" rel="next">What's Next?</a>, Previous: <a href="#Motivation" accesskey="p" rel="prev">Motivation</a>, Up: <a href="#Polyhedral-Representation" accesskey="u" rel="up">Polyhedral Representation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Thinking-in-Polyhedra-1"></span><h3 class="section">2.2 Thinking in Polyhedra</h3>


<p>Since the very first compilers, the internal representation of programs
is the <em>Abstract Syntax Tree</em>, or AST. In such representation,
each statement appears only once even if it is executed many times (e.g.,
when it is enclosed inside a loop). This is a limitation
for finding and applying complex transformations:
</p><ul>
<li> It limits program analysis power. For instance if a statement
      <em>depends</em> on another statement (i.e., they access the same
      memory location and at least one of these accesses is a write),
      we will consider both statements as unique entities while the
      dependence relation may involve only few statement executions.
</li><li> It limits program transformation power. Loop transformations
      operate on statement executions. For instance, because they
      consider all statement executions at the same time, present day
      production compilers are not able to achieve loop fusion
      (that tries to merge the loop bodies of two loops) if the loop bounds
      of the two loops do not match (yes, that&rsquo;s ridiculous).
</li><li> It limits program manipulation flexibility.
      Trees are very rigid data structures that are not easy to manipulate.
      Program transformation may require very complex transformations that will
      imply deep modifications of the control flow.
</li></ul>

<p>The Polyhedral Model is a convenient alternative representation which
combines analysis power, expressiveness and high flexibility. The drawback
is it breaks the classical structure of programs that every programmer
is familiar with. It requires some (real) efforts
to be smoothly manipulated, but it definitely worth it. It is based on three
main concepts, <em>iteration domain</em>,  <em>scattering function</em> and
<em>access function</em> that are described in depth in the
following sections.
</p>
<p>A program part that can be represented using the Polyhedral Model is called
a <strong>Static Control Part</strong> or <strong>SCoP</strong> for short.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Iteration-Domain" accesskey="1">Iteration Domain</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Scattering-Function" accesskey="2">Scattering Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Access-Function" accesskey="3">Access Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Iteration-Domain"></span><div class="header">
<p>
Next: <a href="#Scattering-Function" accesskey="n" rel="next">Scattering Function</a>, Up: <a href="#Thinking-in-Polyhedra" accesskey="u" rel="up">Thinking in Polyhedra</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Iteration-Domain-1"></span><h4 class="subsection">2.2.1 Iteration Domain</h4>

<p>The key aspect of the polyhedral model is to consider <em>statement
instances</em>. A statement instance is <em>one</em> execution of a statement.
A statement
outside a loop has only one instance while those inside loops may have many.
Let us consider the following code with two statements <code>S1</code>
and <code>S2</code>:
</p>
<div class="example">
<pre class="example">pi = 3.14;               // S1
for (i = 0; i &lt; 5; i++)
  A[i] = pi;             // S2
</pre></div>

<p>The list of statement instances is the following (we just have to fully
unroll the loop):
</p>
<div class="example">
<pre class="example">pi = 3.14;
A[0] = pi;
A[1] = pi;
A[2] = pi;
A[3] = pi;
A[4] = pi;
</pre></div>

<p>Each instance of a statement which is enclosed inside a loop may be referred
thanks to its outer loop counters (or <em>iterators</em>). In the polyhedral
model we consider statements as functions of the outer loop counters that may
produce statement instances:
instead of simply &quot;<code>S2</code>&quot;, we use preferably the notation <code>S2(i)</code>.
For instance we  denote the statement instance <code>A[3] = pi;</code> of the
previous example as <code>S2(3)</code>. This means <em>instance of
statement <code>S2</code> for</em> <code>i = 3</code>.
If a statement <code>S3</code> is enclosed inside two loops of iterators <code>i</code>
(outermost loop) and <code>j</code> (innermost loop), we would denote it
<code>S3(i,j)</code>, and so on with more enclosing loops.
</p>
<p>The ordered list
of iterators (ordered from the outermost iterator to the innermost iterator)
is called the <strong>iteration vector</strong>. For instance the iteration vector for
<code>S3</code> is <code>(i,j)</code>, for <code>S2</code> it is <code>(i)</code>, and for <code>S1</code>
it is empty since it has no enclosing loop: <code>()</code>. A more precise reading
at the notation <code>S2(3)</code> would show that it denotes the instance of
statement <code>S2</code> for the iteration vector <code>(2)</code>.
</p>
<p>Obviously, dealing with statement instances does not mean we have to unroll all
loops. First because there would be probably too many instances to deal with,
and second because we probably just do not know how many instances there are.
For instance in the following loop it is impossible to know (at compile time)
how many times the statement <code>S3</code> will be executed:
</p>
<div class="example">
<pre class="example">for (i = 2; i &lt;= N; i++)
  for (j = 2; j &lt;= N; j++)
    A[i] = pi;             // S3
</pre></div>

<p>Such a loop is said to be <em>parametric</em>: it depends on
(at least) a value called a <em>parameter</em> which is not modified
during the execution of the whole loop, but is unknown at compile time.
Here, the only parameter is <code>N</code>.
</p>
<p>A compact way to represent all the instances of a given statement
is to consider the set of all possible values of its iteration vector.
This set is called the <strong>iteration domain</strong>. It can be conveniently
described thanks to all the constraints on the various iterators the statement
depends on. For instance, let us consider
the statement <code>S3</code> of the previous program. The iteration domain is the set
of iteration vectors <code>(i,j)</code>. Because of the parameter, we are not able to
achieve a precise list of all possible values. It would look like this:
</p>
<div class="example">
<pre class="example">(2,2)  (2,3)  (2,4)  ...  (2,N)
(3,2)  (3,3)  (3,4)  ...  (3,N)
...    ...    ...    ...  ...
(N,2)  (N,3)  (N,4)  ...  (N,N)
</pre></div>

<p>A better way is to say it is the set
of iteration vectors <code>(i,j)</code> such that <code>i</code> is an integer greater or
equal than 2 and lower or equal than <code>N</code>, and <code>j</code> is an integer
greater or equal than 2 and lower or equal than <code>N</code>. This may be written
in the following mathematical form:
</p>

<div class="example">
<pre class="example">D_S3 =  {(i,j) in Z^2 | 2 &lt;= i &lt;= N &amp;&amp; 2 &lt;= j &lt;= N }
</pre></div>

<p>It is easy to see that this iteration domain is a part of the
2-dimensional space
</p><div class="example">
<pre class="example">Z^2.
</pre></div>
<p>We often use in our research papers a graphical representation that gives a
better view of this subspace:
</p>
<img src="images/basic1.jpg" alt="images/basic1">

<p>Here, the iteration domain is specified thanks to a set of
constraints. When those constraints are affine and
depend only on the outer loop counters and some parameters, the set of
constraints defines a <em>polyhedron</em> (more precisely this is a
<em>Z-polyhedron</em>, but we use <em>polyhedron</em> for short).
Hence the <em>polyhedral model</em>!
</p>
<p>To manipulate a set of affine constraints easily, we rely on a matrix
representation. To write it, we use the <em>homogeneous</em> iteration vector:
it is simply the iteration vector with some additional dimensions to
represent the parameters and the constant.
For instance for the statement <code>S3</code>, the
iteration vector in homogeneous coordinates is <code>(i, j, N, 1)</code>
(we will now call it <em>iteration vector</em> directly for short).
Then we write all the constraints as affine inequalities of the form
<em>affine constraint</em>
<code> &gt;= 0</code>.
For instance for the statement <code>S3</code> the set of constraints is:
</p>

<div class="example">
<pre class="example">    i - 2 &gt;= 0
   -i + N &gt;= 0
    j - 2 &gt;= 0
   -j + N &gt;= 0
</pre></div>

<p>Lastly, we translate the constraint system to the form
<strong>domain matrix</strong><code> * </code><em>iteration vector</em><code> &gt;= 0</code>:
</p>
<div class="example">
<pre class="example">[  1  0  0 -2 ]   [ i ]    [ 0 ]
[ -1  0  1  0 ]   [ j ]    [ 0 ]
[  0  1  0 -2 ] * [ N ] &gt;= [ 0 ]
[  0 -1  1  0 ]   [ 1 ]    [ 0 ]
</pre></div>

<p><strong>The domain matrix will be used in all our tools to provide the
information on the iteration domain of a given statement (the iteration vector
is in general an implicit information).</strong>
</p>
<hr>
<span id="Scattering-Function"></span><div class="header">
<p>
Next: <a href="#Access-Function" accesskey="n" rel="next">Access Function</a>, Previous: <a href="#Iteration-Domain" accesskey="p" rel="prev">Iteration Domain</a>, Up: <a href="#Thinking-in-Polyhedra" accesskey="u" rel="up">Thinking in Polyhedra</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Scattering-Function-1"></span><h4 class="subsection">2.2.2 Scattering Function</h4>

<p>There is no ordering information inside the iteration domain: it only describes
the set of statement instances but <strong>not</strong> the order in which they have
to be executed relatively to each other. In the past the lexicographic order
of the iteration domain was considered, this is no more true
(especially when using CLooG). If we do not provide any ordering information, this
means that the statement instances may be executed in any order
(this is useful, e.g., to specify parallelism). However, some statement instances
may depend on some others and it may be critical to enforce a given order (or
non-order). Hence we need another information.
</p>
<p>We call <em>scattering</em> any kind of ordering information in the polyhedral
model. There exists many kind of ordering, such as <em>allocation</em>,
<em>scheduling</em>, <em>chunking</em> etc. They are all expressed
in the same way, i.e., using <em>logical stamps</em>, but they may have
different semantics.
</p>
<p>In the case of <strong>scheduling</strong>, the logical stamps are logical dates that
express at which date a statement instance has to be executed. For instance,
let us consider the following three statements:
</p>
<div class="example">
<pre class="example">x = a + b;   // S1
y = c + d;   // S2
z = a * b;   // S3
</pre></div>

<p>The scheduling of a statement <code>S</code> is typically
denoted by
T_S.
Let us consider the following logical dates for each statement:
</p>

<div class="example">
<pre class="example">T_S1 = 1
T_S2 = 2
T_S3 = 3
</pre></div>

<p>It means that statement <code>S3</code> has to be executed at logical date
<code>1</code>, statement <code>S1</code> has to be executed at logical date
<code>2</code> and statement <code>S2</code> has to be executed at logical date
<code>3</code>. The target code has to respect this scheduling (the order of
the logical dates), hence it would look like the following where the
variable <code>t</code> denotes the time:
</p>
<div class="example">
<pre class="example">t = 1;
z = a * b;   // S3
t = 2;
x = a + b;   // S1
t = 3;
y = c + d;   // S2
</pre></div>

<p>When some statements share the same logical date, this means that,
once the program reaches this logical date, the two statements can be executed
in any order, or better, in parallel. For instance let us consider the
following scheduling:
</p>

<div class="example">
<pre class="example">T_S1 = 1
T_S2 = 2
T_S3 = 1
</pre></div>

<p>Statements <code>S1</code> and <code>S3</code> have the same logical date,
moreover, <code>S2</code> has a greater logical date than <code>S1</code> and <code>S3</code>.
Hence the target code would be:
</p>
<div class="example">
<pre class="example">t = 1;
#pragma omp parallel sections
{
   #pragma omp section
   {
     x = a + b;   // S1
   }
   #pragma omp section
   {
     z = a * b;   // S3
   }
}
t = 2;
y = c + d;        // S2
</pre></div>

<p>Logical dates may be multidimensional, as clocks: the first dimension
may correspond to days (most significant), the next one to hours (less
significant), the third to minutes and so on. For instance we can consider
the following multidimensional schedules for our example:
</p>

<div class="example">
<pre class="example">T_S1 = (1,1)
T_S2 = (2,1)
T_S3 = (1,2)
</pre></div>

<p>It is not very hard to decypher the meaning of such scheduling.
Because of the first dimension, statements <code>S1</code> and <code>S3</code> will be
executed before statement <code>S2</code> (<code>S1</code> and <code>S3</code> are executed at
day 1, while <code>S2</code> is executed at day 2). The second dimension is not
really useful there for <code>S2</code> because it is the only statement executed
at day 2. Nevertheless it allows to order <code>S1</code> and
<code>S3</code> relatively to each other since <code>S1</code> is executed at hour 1 of day
1 while <code>S3</code> is executed at hour 2 of day 1.
The corresponding target code is the following, with some
additional time variables for a better view of the ordering (<code>t1</code>
corresponds to the first time dimension, <code>t2</code> to the second one):
</p>
<div class="example">
<pre class="example">t1 = 1;
t2 = 1;
x = a + b;   // S1
t2 = 2;
z = a * b;   // S3
t1 = 2;
t2 = 1;
y = c + d;   // S2
</pre></div>

<p>In the case of <strong>allocation</strong> (in the literature we can find some
papers calling it <em>placement</em>), the logical stamp is a processor
number expressing on which processor a statement instance has to be
executed. Typically, allocations are written in the same way as scheduling.
Here, we denote it <em>P_S</em> for a statement <code>S</code>.
For instance, let us consider the following allocation:
</p>

<div class="example">
<pre class="example">P_S1 = 1
P_S2 = 2
P_S3 = 1
</pre></div>

<p>The corresponding target code has to take into account that both
statements <code>S1</code> and <code>S3</code> have to be executed on the same processor
(they have the same logical number 1) and that statement <code>S2</code> has
to be executed on another processor (logical number 2). A possible target code
is the following:
</p>
<div class="example">
<pre class="example">#pragma omp parallel sections
{
   #pragma omp section
   {
     // Logical processor 1
     x = a + b;   // S1
     z = a * b;   // S3
   }
   #pragma omp section
   {
     // Logical processor 2
     y = c + d;   // S2
   }
}
</pre></div>

<p>We can note that no order has been specified for the
statements <code>S1</code> and <code>S3</code> that are executed on the same processor.
Hence any order is satisfying. For sake of flexibility, it is usual to build
a scattering whose various dimensions do not have the same semantics. A
typical construction is <em>space/time mapping</em> where the first <code>n</code>
dimensions are devoted to allocation, then the last <code>m</code>
dimensions are devoted to scheduling. Typically, space/time mapping is
written in the same way as scheduling.
Here we denote it <em>M_S</em> for a statement <code>S</code>.
For instance, let us consider the following space/time mapping for our
example where one dimension is devoted to mapping and one dimension is
devoted to scheduling:
</p>

<div class="example">
<pre class="example">M_S1 = (1,2)
M_S2 = (2,1)
M_S3 = (1,1)
</pre></div>

<p>Here we have the same first dimension as the previous example, thus
the allocation of the statements to processors is the same. The second
dimension precises on a given processor at which logical date a statement
instance has to be executed. Here, the statement <code>S1</code> is executed at
day 2 on processor 1 while the statement <code>S3</code> is executed at day 1 onto
the same processor. It follows this space/time mapping corresponds to the
following target code (we added an additional variable to represent the
local logical clocks):
</p>
<div class="example">
<pre class="example">#pragma omp parallel sections
{
   #pragma omp section
   {
     // Logical processor 1
     t = 1;
     z = a * b;   // S3
     t = 2;
     x = a + b;   // S1
   }
   #pragma omp section
   {
     // Logical processor 2
     t = 1;
     y = c + d;   // S2
   }
}
</pre></div>

<p>For the same reason as discussed for iteration domains
(see <a href="#Iteration-Domain">Iteration Domain</a>), it is not possible to define a scattering for
each statement instance, especially if the statement belongs to a
(possibly parametric) loop. The iteration vector fully defines an
instance of a given statement. Thus, a practical way to provide a scattering
for each instance of a given statement is to use a <em>function</em>
that depends on the iteration vector. In this way the function may associate
to each iteration vector a different scattering. We call these functions
<strong>scattering functions</strong>. Scattering functions are <em>affine</em>
functions of the outer loop counter and the global parameters.
For instance, let us consider the following source code:
</p>
<div class="example">
<pre class="example">for (i = 2; i &lt;= 4; i++)
  for (j = 2; j &lt;= 4; j++)
    P[i+j] += A[i] + B[j]; // S4
</pre></div>

<p>The iteration domain of the statement <code>S4</code> is:
</p>

<div class="example">
<pre class="example">D_S4=  {(i,j) in Z^2 | 2 &lt;= i &lt;= 4 &amp;&amp; 2 &lt;= j &lt;= 4 }.
</pre></div>

<p>If you are still not comfortable with the mathematical notation, it
corresponds to the following graphical representation:
</p>
<img src="images/basic2.jpg" alt="images/basic2">

<p>The list of the statement instances of <code>S4</code> (the integer
points of its iteration domain) corresponds to the following iteration vectors:
</p>
<div class="example">
<pre class="example">iteration vector
     (2,2)
     (2,3)
     (2,4)
     (3,2)
     (3,3)
     (3,4)
     (4,2)
     (4,3)
     (4,4)
</pre></div>

<p>Let us suppose we want to schedule the instances of the statement
<code>S4</code> (the integer points of its iteration domain) using the following
scheduling function:
</p>

<div class="example">
<pre class="example">T_S4(i,j) = (j+2,3*i+j)
</pre></div>

<p>We only need to apply the function to each iteration vector to find
the logical date of each instance:
</p>
<div class="example">
<pre class="example">iteration vector       logical date
     (2,2)       --&gt;       (4,8)
     (2,3)       --&gt;       (5,9)
     (2,4)       --&gt;       (6,10)
     (3,2)       --&gt;       (4,11)
     (3,3)       --&gt;       (5,12)
     (3,4)       --&gt;       (6,13)
     (4,2)       --&gt;       (4,14)
     (4,3)       --&gt;       (5,15)
     (4,4)       --&gt;       (6,16)
</pre></div>

<p>The polyhedral model users do not have to take care about the generation of a
target code that respects the scattering: the
CLooG<a id="DOCF1" href="#FOOT1"><sup>1</sup></a> tool is there to
solve the problem quite easily. For the previous
example, the target code would be the following (<code>t1</code> and <code>t2</code>
correspond to the two dimensions of the logical date, the reader may
take care that this code actually implements the scattering function):
</p>
<div class="example">
<pre class="example">for (t1 = 4; t1 &lt;= 6; t1++) {
  for (t2 = t1+4; t2 &lt;= t1+10; t2++) {
    if ((-t1+t2+2)%3 == 0) {
      i = (-t1+t2+2)/3 ;
      j = t1-2 ;
      P[i+j] += A[i] + B[j]; // S4
    }
  }
}
</pre></div>



<p>Obviously with such a twisted scheduling, it is hard to see the &quot;meaning&quot;
of the transformation. To name any kind of program transformation as
a magic spell (&quot;tile&quot;, &quot;fuse&quot;, &quot;skew&quot;...) is an old bad habit which is not
relevant anymore in the polyhedral model: a scheduling may be an arbitrary
complex sequence of basic-old-good transformations. Nevertheless it is most
of the time quite easy to translate well known transformations to schedules.
For instance, let us consider this new scheduling function:
</p>

<div class="example">
<pre class="example">T_S4(i,j) = (j,i)
</pre></div>

<p>Using CLooG, we can generate the target code:
</p>
<div class="example">
<pre class="example">for (t1 = 2; t1 &lt;= 4; t1++) {
  for (t2 = 2; t2 &lt;= 4; t2++) {
    i = t2;
    j = t1;
    P[i+j] += A[i] + B[j]; // S4
  }
}
</pre></div>


<p>It is easy to see (and analyze) that it corresponds to a classical
<em>loop interchange</em> transformation.
</p>
<p>A very useful example of multi-dimensional scattering functions is
the <strong>scheduling of the original program</strong>.
The method to compute it is quite simple (see <a href="#Fea92">Fea92</a>). The idea is to
build an abstract syntax tree of the program and to read the scheduling for
each statement. For instance, let us consider the following implementation of
a Cholesky factorization:
</p>
<div class="example">
<pre class="example">/* A Cholesky factorization kernel. */
for (i=1;i&lt;=N;i++) {
  for (j=1;j&lt;=i-1;j++) {
    a[i][i] -= a[i][j] ;           // S1
  }
  a[i][i] = sqrt(a[i][i]) ;        // S2
  for (j=i+1;j&lt;=N;j++) {
    for (k=1;k&lt;=i-1;k++) {
      a[j][i] -= a[j][k]*a[i][k] ; // S3
    }
    a[j][i] /= a[i][i] ;           // S4
    }
  }
}
</pre></div>

<p>The corresponding abstract syntax tree is shown in the following
figure. It directly gives the scattering functions (schedules) for all the
statements of the program (just follow the paths).
</p>
<img src="images/tree.jpg" alt="images/tree">


<div class="example">
<pre class="example">T_S1(i,j)   = (0,i,0,j,0)
T_S2(i)     = (0,i,1)
T_S3(i,j,k) = (0,i,2,j,0,k,0)
T_S4(i,j)   = (0,i,2,j,1)
</pre></div>

<p>These schedules depend on the iterators and give for each instance
of each statement a unique execution date. Using such scattering functions
allows CLooG to re-generate the input code.
</p>
<p>To easily manipulate the scattering function of any
statement <code>S</code>, we translate it to the matrix form:
T_S(<em>iteration vector</em>)
<code> = </code><strong>scattering matrix</strong><code> * </code><em>iteration vector</em>.
For instance let us consider again our previous example
T_S4(i,j) = (j+2,3*i+j).
We write it in the following way:
</p><div class="example">
<pre class="example">     [ i ]    [  0  1  2 ]   [ i ]
T_S4([ j ]) = [  3  1  0 ] * [ j ]
     [ 1 ]                   [ 1 ]
</pre></div>

<p><strong>The scattering matrix will be used in all our tools to provide
the information on the scattering of a given statement
(the iteration vector is in general an implicit information).</strong>
</p>

<hr>
<span id="Access-Function"></span><div class="header">
<p>
Previous: <a href="#Scattering-Function" accesskey="p" rel="prev">Scattering Function</a>, Up: <a href="#Thinking-in-Polyhedra" accesskey="u" rel="up">Thinking in Polyhedra</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Access-Function-1"></span><h4 class="subsection">2.2.3 Access Function</h4>

<p>Before applying any transformation, it is essential to deeply analyze both the
original program and the transformation to ensure the transformation does not
imply any modification of the original program semantics. In the polyhedral
model, we are able to achieve
an exact analysis when all the memory accesses are made through arrays
(note that variables are a particular case of arrays since they are simply
arrays with only one memory location) with affine subscripts that depend
on outer loop counters and global parameters (note that <em>subscripts</em>
are sometimes called <em>index</em> or <em>accesses</em> in the literature).
</p>
<p>For instance let us consider the array access <code>A[2*i+j][j][i+N]</code>. It has
three dimensions, each subscript dimension is an affine form of some outer loop
iterarors (<code>i</code> and <code>j</code>) and global parameters (<code>N</code>) hence
it corresponds to an acceptable array access to be analyzed in the
polyhedral model.
</p>
<p>Each array access can target a different memory cell depending on the
statement instance, i.e., depending on the iteration vector.
Thus we use access functions (or subscript functions, or index functions, as you
prefer to call it) depending on the iteration vector to describe an array
access. In our example, the access function would be written
<em>F_A(i, j) = (2*i+j, j, i+N)</em>.
</p>
<p>To easily manipulate the access function of any
array <code>A</code>, we translate it to the matrix form:
<em>F_A</em>(<em>iteration vector</em>)
<code> = </code><strong>access matrix</strong><code> * </code><em>iteration vector</em>.
For instance let us consider again our previous example. We would
write it in the following way:
</p><div class="example">
<pre class="example">    [ i ]    [  2  1  0  0 ]   [ i ]
F_A([ j ]) = [  0  1  0  0 ] * [ j ]
    [ N ]    [  1  0  1  0 ]   [ N ]
    [ 1 ]                      [ 1 ]
</pre></div>

<p><strong>The access matrix will be used in all our tools to provide the
information on the access of a given statement
(the iteration vector is in general an implicit information).</strong>
</p>
<hr>
<span id="What_0027s-Next_003f"></span><div class="header">
<p>
Previous: <a href="#Thinking-in-Polyhedra" accesskey="p" rel="prev">Thinking in Polyhedra</a>, Up: <a href="#Polyhedral-Representation" accesskey="u" rel="up">Polyhedral Representation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="What_0027s-Next_003f-1"></span><h3 class="section">2.3 What&rsquo;s Next?</h3>

<p>OK, now you have an idea about how we do represent a program part in the
polyhedral model. You know the three main concepts, namely: domain, scattering
and access. What can you do with this?! Well, pretty much anything related
to code restructuring! The core idea will be to rely on the mathematical
representation to extract useful information about your
code (data reuse, parallelism...) and to generate a scattering
to benefit from the properties you analysed.
However, OpenScop&rsquo;s documentation is not the right
place to learn at this (OpenScop is all about representation, not about
manipulation). Probably it is the right time for you to
have a look at:
</p><ul>
<li> PoCC <a href="http://pocc.sourceforge.net">http://pocc.sourceforge.net</a>
</li><li> Pluto <a href="http://pluto-compiler.sourceforge.net">http://pluto-compiler.sourceforge.net</a>
</li></ul>

<p>Have fun :-) !
</p>

<hr>
<span id="OpenScop-Specification"></span><div class="header">
<p>
Next: <a href="#OpenScop-Library" accesskey="n" rel="next">OpenScop Library</a>, Previous: <a href="#Polyhedral-Representation" accesskey="p" rel="prev">Polyhedral Representation</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="OpenScop-Specification-1"></span><h2 class="chapter">3 OpenScop Specification</h2>

<p>OpenScop provides an explicit polyhedral representation of a static control
part. It has been designed by various polyhedral compilation tool writers from
various institutions. It builds on previous popular polyhedral file and data
structure formats (such as <em>.cloog</em> and CLooG data structures) to provide
a unique, extensible format to most polyhedral compilation tools. It
is composed of two parts. The first part, the so-called 
<em>core part</em>, is devoted to the polyhedral representation of a SCoP.
It contains what is strictly necessary to build a
complete source-to-source framework in the polyhedral model and to output a
semantically equivalent code for the SCoP, from analysis to code generation.
The second part of the format, the so-called <em>extension part</em>,
contains extensions to provide additional informations to some tools.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Preliminary-Example" accesskey="1">Preliminary Example</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenScop-File-Format-Specification" accesskey="2">OpenScop File Format Specification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#OpenScop-Data-Structure-Specification" accesskey="3">OpenScop Data Structure Specification</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extensions" accesskey="4">Extensions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#History" accesskey="5">History</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Preliminary-Example"></span><div class="header">
<p>
Next: <a href="#OpenScop-File-Format-Specification" accesskey="n" rel="next">OpenScop File Format Specification</a>, Up: <a href="#OpenScop-Specification" accesskey="u" rel="up">OpenScop Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Preliminary-Example-1"></span><h3 class="section">3.1 Preliminary Example</h3>
<p>OpenScop is a specification for representing static control program parts in
the polyhedral model. Thus, we can translate some code parts to an equivalent
OpenScop representation. As an example, let us consider the
following matrix-multiply kernel:
</p>
<div class="example">
<pre class="example">#pragma scop
if (N &gt; 0) {
  for (i = 0; i &lt; N; i++) {
    for (j = 0; j &lt; N; j++) {
      C[i][j] = 0.0;
      for (k = 0; k &lt; N; k++)
        C[i][j] = C[i][j] + A[i][k] * B[k][j];
    }
  }
}
</pre></div>

<p>The Clan<a id="DOCF2" href="#FOOT2"><sup>2</sup></a>
tool may be used to translate this code part to an OpenScop
representation automatically. The <code>#pragma scop</code> is used here for
Clan, but some other tool may not need it. Here is the result of the
translation to an OpenScop textual representation.
</p>
<br>
<div align="center"><strong>DON&rsquo;T PANIC</strong>
</div><br>

<p>Explanations will follow and it is not
as cryptic as it seems to be !
</p><br>

<div class="example">
<pre class="example">&lt;OpenScop&gt;

# =============================================== Global
# Backend Language
C

# Context
CONTEXT
1 3 0 0 0 1
# e/i | N  | 1
   1    1   -1    ## N-1 &gt;= 0

# Parameter names are provided
1
# Parameter names
&lt;strings&gt;
N
&lt;/strings&gt;

# Number of statements
2

# =============================================== Statement 1
# Number of relations describing the statement
3

# ----------------------------------------------  1.1 Domain
DOMAIN
4 5 2 0 0 1
# e/i | i    j  | N  | 1
   1    1    0    0    0    ## i &gt;= 0
   1   -1    0    1   -1    ## -i+N-1 &gt;= 0
   1    0    1    0    0    ## j &gt;= 0
   1    0   -1    1   -1    ## -j+N-1 &gt;= 0

# ----------------------------------------------  1.2 Scattering
SCATTERING
5 10 5 2 0 1
# e/i| s1   s2   s3   s4   s5  | i    j  | N  | 1 
   0   -1    0    0    0    0    0    0    0    0    ## s1 = 0
   0    0   -1    0    0    0    1    0    0    0    ## s2 = i
   0    0    0   -1    0    0    0    0    0    0    ## s3 = 0
   0    0    0    0   -1    0    0    1    0    0    ## s4 = j
   0    0    0    0    0   -1    0    0    0    0    ## s5 = 0

# ----------------------------------------------  1.3 Access
WRITE
3 8 3 2 0 1
# e/i| Arr  [1]  [2] | i    j  | N  | 1
   0   -1    0    0    0    0    0    1    ## C
   0    0   -1    0    1    0    0    0    ##  [i]
   0    0    0   -1    0    1    0    0    ##     [j]

# ----------------------------------------------  1.4 Statement Extensions
# Number of Statement Extensions
1
&lt;body&gt;
# Number of original iterators
2
# Original iterator names
i j 
# Statement body expression
C[i][j] = 0.0;
&lt;/body&gt;

# =============================================== Statement 2
# Number of relations describing the statement
5

# ----------------------------------------------  2.1 Domain
DOMAIN
6 6 3 0 0 1
# e/i|  i    j    k  | N  | 1
   1    1    0    0    0    0    ## i &gt;= 0
   1   -1    0    0    1   -1    ## -i+N-1 &gt;= 0
   1    0    1    0    0    0    ## j &gt;= 0
   1    0   -1    0    1   -1    ## -j+N-1 &gt;= 0
   1    0    0    1    0    0    ## k &gt;= 0
   1    0    0   -1    1   -1    ## -k+N-1 &gt;= 0

# ----------------------------------------------  2.2 Scattering
SCATTERING
7 13 7 3 0 1
# e/i| s1   s2   s3   s4   s5   s6   s7  | i    j    k  | N  | 1
   0   -1    0    0    0    0    0    0    0    0    0    0    0   ## s1 = 0
   0    0   -1    0    0    0    0    0    1    0    0    0    0   ## s2 = i
   0    0    0   -1    0    0    0    0    0    0    0    0    0   ## s3 = 0
   0    0    0    0   -1    0    0    0    0    1    0    0    0   ## s4 = j
   0    0    0    0    0   -1    0    0    0    0    0    0    1   ## s5 = 1
   0    0    0    0    0    0   -1    0    0    0    1    0    0   ## s6 = k
   0    0    0    0    0    0    0   -1    0    0    0    0    0   ## s7 = 0

# ----------------------------------------------  2.3 Access
WRITE
3 9 3 3 0 1
# e/i| Arr  [1]  [2] | i    j    k  | N  | 1
   0   -1    0    0    0    0    0    0    1    ## C
   0    0   -1    0    1    0    0    0    0    ##  [i]
   0    0    0   -1    0    1    0    0    0    ##     [j]

READ
3 9 3 3 0 1
# e/i| Arr  [1]  [2] | i    j    k  | N  | 1
   0   -1    0    0    0    0    0    0    1    ## C
   0    0   -1    0    1    0    0    0    0    ##  [i]
   0    0    0   -1    0    1    0    0    0    ##     [j]

READ
3 9 3 3 0 1
# e/i| Arr  [1]  [2] | i    j    k  | N  | 1
   0   -1    0    0    0    0    0    0    2    ## A
   0    0   -1    0    1    0    0    0    0    ##  [i]
   0    0    0   -1    0    0    1    0    0    ##     [k]

READ
3 9 3 3 0 1
# e/i| Arr  [1]  [2] | i    j    k  | N  | 1
   0   -1    0    0    0    0    0    0    3    ## B
   0    0   -1    0    0    0    1    0    0    ##  [k]
   0    0    0   -1    0    1    0    0    0    ##     [j]

# ----------------------------------------------  1.4 Statement Extensions
# Number of Statement Extensions
1
&lt;body&gt;
# Number of original iterators
3
# Original iterator names
i j k 
# Statement body expression
C[i][j] = C[i][j] + A[i][k] * B[k][j];
&lt;/body&gt;

# =============================================== Extensions
&lt;comment&gt;
May the power of the polyhedral model be with you. 
&lt;/comment&gt;

&lt;/OpenScop&gt;
</pre></div>


<p>We will not describe here precisely the structure and the components of this
output, this is described in depth in a further section
(see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>). This format
has been designed to be a possible input or output file format of most of
polyhedral compilation tools. If you read the description of the polyhedral
representation of programs, you should already feel familiar with this file
format (see <a href="#Polyhedral-Representation">Polyhedral Representation</a>).
</p>

<hr>
<span id="OpenScop-File-Format-Specification"></span><div class="header">
<p>
Next: <a href="#OpenScop-Data-Structure-Specification" accesskey="n" rel="next">OpenScop Data Structure Specification</a>, Previous: <a href="#Preliminary-Example" accesskey="p" rel="prev">Preliminary Example</a>, Up: <a href="#OpenScop-Specification" accesskey="u" rel="up">OpenScop Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="OpenScop-File-Format-Specification-1"></span><h3 class="section">3.2 OpenScop File Format Specification</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Relations" accesskey="1">Relations</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Generics" accesskey="2">Generics</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>The following grammar describes the structure of the
OpenScop file format where terminals are preceeded by &quot;_&quot;. Except
stated otherwise, there can be at most one terminal per line in the file.
Moreover, each line may finish with a comment, starting by the &lsquo;<samp>#</samp>&rsquo;
character. Each relevant part will be explained in more details momentarily:
</p>
<div class="example">
<pre class="example">OpenScop              ::= Start_tag Data End_tag
Start_tag             ::= &quot;&lt;OpenScop&gt;&quot;
End_tag               ::= &quot;&lt;/OpenScop&gt;&quot;
Data                  ::= Context Statements Extension_list
Context               ::= Language Parameter_Domain Parameters
Statements            ::= Nb_statements Statement_list
Statement_list        ::= Statement Statement_list | (void)
Relation_list         ::= _Relation Relation_list  | (void)
Extension_list        ::= _Generic  Extension_list | (void)
Statement             ::= Statement_relations Statement_extensions
Statement_extensions  ::= Num_Extensions Extension_list
Parameters            ::= &quot;0&quot; | &quot;1&quot; Parameter_information
Statement_relations   ::= Nb_relations Relation_List 
Parameter_domain      ::= _Relation
Language              ::= _String
Nb_Relations          ::= _Integer
Num_extensions        ::= _Integer
Parameter_information ::= _Generic
</pre></div>

<p>The &lsquo;<samp>Context</samp>&rsquo; and the &lsquo;<samp>Statements</samp>&rsquo; parts compose the
<em>core part</em>, i.e., what is strictly necessary to build
a complete source to source framework based on OpenSCop:
</p><ul>
<li> &lsquo;<samp>Context</samp>&rsquo; represents the global information of the SCoP. It
       consists on the target language, the global constraints on the
       parameters and optionally the parameter information which may be necessary
       for the code generation process. The constraints on the parameters
       are represented as a relation (see <a href="#Context-Domain-Relation">Context Domain Relation</a>).
       The parameter information is optional. It is preceded by a
       boolean which precises whether it is provided or not.
       It is a generic information (see <a href="#Generics">Generics</a>), a <code>strings</code>
       (see <a href="#Strings-Generic">Strings Generic</a>) for instance.
</li><li> &lsquo;<samp>Statements</samp>&rsquo; represents the information about the statements.
       &lsquo;<samp>Nb_statements</samp>&rsquo; is the number of statements in the SCoP,
       i.e. the number of &lsquo;<samp>Statement</samp>&rsquo; items in the &lsquo;<samp>Statement_list</samp>&rsquo;.
       &lsquo;<samp>Statement</samp>&rsquo; represents the information on a given statement.
       To each statement is associated a list of relations and,
       optionaly, a list of statement extensions. The list of relations
       may include one iteration domain (see <a href="#Iteration-Domain-Relation">Iteration Domain Relation</a>),
       one scattering relation (see <a href="#Scattering-Relation">Scattering Relation</a>)
       and several access relations (see <a href="#Access-Relation">Access Relation</a>).
       There is no mandatory ordering, but for consistency reason it would
       be much appreciated that iteration domain comes first (if present)
       then scattering (if present), then accesses (if present).
       The statement extensions is an optional information. It starts with a
       integer which precises the number of extensions provided. 
       It is generic information (see <a href="#Generics">Generics</a>), a <code>body</code>
       (see <a href="#Body-Generic">Body Generic</a>) for instance.
</li></ul>

<p>The &lsquo;<samp>Extension_list</samp>&rsquo; represents the <em>extension part</em> and may contain
an arbitrary number of generic informations (see <a href="#Generics">Generics</a>).
Few examples of possible extensions are presented in a further
section (see <a href="#Extensions">Extensions</a>).
</p>
<p>As shown by the grammar, the input file describes the various pieces of
information based on strings, integers, <em>relations</em> and <em>generics</em>.
Relations and Generics are specific to OpenScop and are described in depth
in the following Sections (see <a href="#Relations">Relations</a> and see <a href="#Generics">Generics</a>).
</p>

<hr>
<span id="Relations"></span><div class="header">
<p>
Next: <a href="#Generics" accesskey="n" rel="next">Generics</a>, Up: <a href="#OpenScop-File-Format-Specification" accesskey="u" rel="up">OpenScop File Format Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Relations-1"></span><h4 class="subsection">3.2.1 Relations</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Iteration-Domain-Relation" accesskey="1">Iteration Domain Relation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Context-Domain-Relation" accesskey="2">Context Domain Relation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Scattering-Relation" accesskey="3">Scattering Relation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Access-Relation" accesskey="4">Access Relation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><em>Relations</em> are the essence of the OpenScop format and contain the
&quot;polyhedral&quot; information. They are used to describe either an iteration
domain, or a context domain, or a scattering or a memory access.
</p>
<p>We use the relation term as a shortcut to denote a
union of convex relations, each element of the union being described by a set of
constraints in an extended PolyLib format (see <a href="#Wil93">Wil93</a>).
The number of elements in the union is given by an integer on the first line,
optionally followed by a comment starting with &lsquo;<samp>#</samp>&rsquo;.
This number of elements can be omitted when there is only one element.
Each element in the union has the following syntax:
</p>
<ol>
<li> Some optional comment lines beginning with &lsquo;<samp>#</samp>&rsquo;.
</li><li> A line with the type of the relation, possibly followed by comments.
      The type can be one of the following:
      <ul>
<li> <code>UNDEFINED</code>: generic relation,
      </li><li> <code>CONTEXT</code>: for context information,
      </li><li> <code>DOMAIN</code>: for iteration domains,
      </li><li> <code>SCATTERING</code>: for scattering relation,
      </li><li> <code>READ</code>: for read accesses,
      </li><li> <code>WRITE</code>: for write accesses,
      </li><li> <code>MAY_WRITE</code>: for may-write accesses,
      </li></ul>
</li><li> A line with 6 numbers, possibly followed by comments:
      <ol>
<li> the number of rows of the constraint matrix,
      </li><li> the number of columns of the constraint matrix,
      </li><li> the number of <em>output dimensions</em>,
      </li><li> the number of <em>input dimension</em>,
      </li><li> the number of <em>local dimensions</em>
            (existentially quantified dimensions),
      </li><li> the number of <em>parameters</em>.
      </li></ol>
<p>The sum of the last four numbers should be equal to the number of columns
      minus two. The remaining two columns are the equality/inequality
      indicator and the constant term. The number of parameters should be the
      same for all relations in the entire OpenScop file or data structure.
</p></li><li> The constraint rows. Each row corresponds to a constraint the
      relation has to satisfy. Each row must be on a single line and is possibly
      followed by comments. The constraint is an equality <em>p(x) = 0</em> if the
      first element is 0, an inequality  <em>p(x) \geq 0</em> if the first element
      is 1. The next elements are the coefficients of the output dimensions,
      followed by coefficients of the input dimensions, the existentially
      quantified dimensions and finally the parameters.
      The last element is the constant term.
</li></ol>

<p>This representation is the basis for several purposes. Examples for
iteration domains (see <a href="#Iteration-Domain-Relation">Iteration Domain Relation</a>), context domains
(see <a href="#Context-Domain-Relation">Context Domain Relation</a>), scattering
relations (see <a href="#Scattering-Relation">Scattering Relation</a>) and
access relations (see <a href="#Access-Relation">Access Relation</a>) are provided in further sections.
</p>
<hr>
<span id="Iteration-Domain-Relation"></span><div class="header">
<p>
Next: <a href="#Context-Domain-Relation" accesskey="n" rel="next">Context Domain Relation</a>, Up: <a href="#Relations" accesskey="u" rel="up">Relations</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Iteration-Domain-Relation-1"></span><h4 class="subsubsection">3.2.1.1 Iteration Domain Relation</h4>

<p>Iteration domain represents the set of instances of the corresponding statement.
OpenScop iteration domains are represented as relations with the following
conventions:
</p><ul>
<li> the type is <code>DOMAIN</code>,
</li><li> there is 0 input dimension,
</li><li> loop iterators correspond to output dimensions.
</li></ul>

<p>For instance, assuming that &lsquo;<samp>i</samp>&rsquo;, &lsquo;<samp>j</samp>&rsquo; and &lsquo;<samp>k</samp>&rsquo; are the loop
iterators and &lsquo;<samp>M</samp>&rsquo; and &lsquo;<samp>N</samp>&rsquo; are the parameters, the domain defined by
the following constraints :
</p>
<div class="example">
<pre class="example">   -i + M &gt;= 0
   -j + N &gt;= 0
i + j - k &gt;= 0
</pre></div>

<p>can be written in the input file as follows:
</p>
<div class="example">
<pre class="example"># This is an iteration domain
DOMAIN
1 # Number of relations in the union
3 7 3 0 0 2                  # 3 rows, 7 cols: 3 output dims and 2 params
# e/i| i   j   k | M   N | 1
   1  -1   0   0   1   0   0 #    -i + M &gt;= 0
   1   0  -1   0   0   1   0 #    -j + N &gt;= 0
   1   1   1  -1   0   0   0 # i + j - k &gt;= 0
</pre></div>

<p>Equivalently, it can be written in the following way as the number
of relations in the union can be omitted if it is 1:
</p>
<div class="example">
<pre class="example"># This is an iteration domain
DOMAIN
3 7 3 0 0 2                  # 3 rows, 7 cols: 3 output dims and 2 params
# e/i| i   j   k | M   N | 1
   1  -1   0   0   1   0   0 #    -i + M &gt;= 0
   1   0  -1   0   0   1   0 #    -j + N &gt;= 0
   1   1   1  -1   0   0   0 # i + j - k &gt;= 0
</pre></div>

<p>As an example for unions, let us consider the following pseudo-code:
</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= N; i++) {
  if ((i &gt;= M) || (i &lt;= 2*M))
    S1(i);
}
</pre></div>

<p>The iteration domain of &lsquo;<samp>S1</samp>&rsquo; can be divided into two
relations and written in the OpenScop file as follows:
</p>
<div class="example">
<pre class="example"># This is an iteration domain
DOMAIN
2 # Number of relations in the union
# Union part No.1
3 5 1 0 0 2          # 3 rows, 5 cols: 1 output dim and 2 params
# e/i| i | M   N | 1
   1   1   0   0  -1 #  i &gt;= 1
   1  -1   0   1   0 #  i &lt;= N
   1   1  -1   0   0 #  i &gt;= M
# Union part No.2
3 5 1 0 0 2          # 3 rows, 5 cols: 1 output dim and 2 params
# e/i| i | M   N | 1
   1   1   0   0  -1 #  i &gt;= 1
   1  -1   0   1   0 #  i &lt;= N
   1  -1   2   0   0 #  i &lt;= 2*M
</pre></div>

<p>As an example for local dimensions (existentially quantified
dimensions), let us consider the following pseudo-code:
</p>
<div class="example">
<pre class="example">for (i = 1; i &lt;= N; i++) {
  if ((i % 2) == 0)
    S1(i);
}
</pre></div>

<p>The iteration domain of &lsquo;<samp>S1</samp>&rsquo; is composed of all even
integer values between 1 and N. The &quot;divisible by two&quot; constraint can
be expressed as follows: there exists an integer &lsquo;<samp>ld</samp>&rsquo; such that
&lsquo;<samp>i = 2*ld</samp>&rsquo;. We encode this thanks to a new local dimension:
</p>
<div class="example">
<pre class="example"># This is an iteration domain
DOMAIN
3 5 1 0 1 1          # 3 rows, 5 cols: 1 output dim, 1 local dim, 1 param
# e/i| i |ld | N | 1
   0   1  -2   0   0 #  i = 2*ld
   1   1   0   0   1 #  i &gt;= 1
   1  -1   0   1   0 #  i &lt;= N
</pre></div>


<hr>
<span id="Context-Domain-Relation"></span><div class="header">
<p>
Next: <a href="#Scattering-Relation" accesskey="n" rel="next">Scattering Relation</a>, Previous: <a href="#Iteration-Domain-Relation" accesskey="p" rel="prev">Iteration Domain Relation</a>, Up: <a href="#Relations" accesskey="u" rel="up">Relations</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Context-Domain-Relation-1"></span><h4 class="subsubsection">3.2.1.2 Context Domain Relation</h4>

<p>The context domain is a particular case of iteration domain
(see <a href="#Iteration-Domain-Relation">Iteration Domain Relation</a>) where there are only
constraints about parameters (no loop iterators). Hence it is the same
as an iteration domain, with the following conventions:
</p><ul>
<li> the type is <code>CONTEXT</code>,
</li><li> there is 0 input dimension,
</li><li> there is 0 output dimension.
</li></ul>


<hr>
<span id="Scattering-Relation"></span><div class="header">
<p>
Next: <a href="#Access-Relation" accesskey="n" rel="next">Access Relation</a>, Previous: <a href="#Context-Domain-Relation" accesskey="p" rel="prev">Context Domain Relation</a>, Up: <a href="#Relations" accesskey="u" rel="up">Relations</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Scattering-Relation-1"></span><h4 class="subsubsection">3.2.1.3 Scattering Relation</h4>

<p>Scattering relation maps an iteration domain to a logical time and/or
space (and/or) anything.
OpenScop scattering information is represented as relations
(see <a href="#Relations">Relations</a>) with the following conventions:
</p>
<ul>
<li> the type is <code>SCATTERING</code>,
</li><li> output dimensions correspond to scattering dimensions,
</li><li> loop iterators correspond to input dimensions.
</li></ul>

<p>As an example of a scattering relation and
assuming that &lsquo;<samp>i</samp>&rsquo;, &lsquo;<samp>j</samp>&rsquo; and &lsquo;<samp>k</samp>&rsquo; are the loop
iterators and &lsquo;<samp>M</samp>&rsquo; and &lsquo;<samp>N</samp>&rsquo; are the parameters, take for instance:
</p><div class="example">
<pre class="example">T_{S}(i,j,k) = (j+2,3*i+j,k+N+1).
</pre></div>
<p>We can represent it in the following way:
</p>
<div class="example">
<pre class="example"># A scattering relation
SCATTERING
# 3 rows, 10 columns: 3 scattering dimensions, 3 iterators, 2 parameters
3 10 3 3 0 2
# e/i|s1  s2  s3 | i   j   k | M   N | 1
   0  -1   0   0   0   1   0   0   0   2 # s1 = j+2
   0   0  -1   0   3   1   0   0   0   0 # s2 = 3*i+j
   0   0   0  -1   0   0   1   0   1   1 # s3 = k+N+1
</pre></div>

<hr>
<span id="Access-Relation"></span><div class="header">
<p>
Previous: <a href="#Scattering-Relation" accesskey="p" rel="prev">Scattering Relation</a>, Up: <a href="#Relations" accesskey="u" rel="up">Relations</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Access-Relation-1"></span><h4 class="subsubsection">3.2.1.4 Access Relation</h4>

<p>Access relation maps an iteration domain to an array space.
Each array accessed in the SCoP has a unique identification number.
OpenScop relation information is represented as relations
(see <a href="#Relations">Relations</a>) with the following conventions:
</p>
<ul>
<li> the type is one of the following:
      <ul>
<li> <code>READ</code>, for read accesses,
      </li><li> <code>WRITE</code>, for write accesses,
      </li><li> <code>MAY_WRITE</code>, for may write accesses,
      </li></ul>
</li><li> output dimensions correspond to the array identifier and dimensions,
</li><li> the first output dimension corresponds to the array identifier,
</li><li> the (i+1)th output dimension corresponds to the ith array dimension (i&gt;1),
</li><li> loop iterators correspond to input dimensions.
</li></ul>

<p>As an example of a scattering relation and
assuming that &lsquo;<samp>i</samp>&rsquo;, &lsquo;<samp>j</samp>&rsquo; and &lsquo;<samp>k</samp>&rsquo; are the loop
iterators and &lsquo;<samp>M</samp>&rsquo; and &lsquo;<samp>N</samp>&rsquo; are the parameters, let us consider
the array access <code>A[2*i+j][j][i+N]</code> (the identifier of <code>A</code> is 42),
and let us suppose this is a read access. Its representation would be the
following:
</p>
<div class="example">
<pre class="example"># A read access relation
READ
# 4 rows, 11 columns: 4 array dimensions, 3 iterators, 2 parameters
4 11 4 3 0 2
# e/i|Arr [1] [2] [3]| i   j   k | M   N | 1
   0  -1   0   0   0   0   0   0   0   0  42   # A
   0   0  -1   0   0   2   1   0   0   0   0   #  [2*i+j]
   0   0   0  -1   0   0   1   0   0   0   0   #         [j]
   0   0   0   0  -1   1   0   0   0   1   0   #            [i+N]
</pre></div>

<p>To understand this representation, consider that OpenScop accesses
are general memory accesses and not array accesses. The memory is
seen as a big array <code>Mem</code> while usual array names correspond to
the first dimension. Hence our example translates to <code>Mem[42][2*i+j][j][i+N]</code>.
</p>
<p>Unions of access relations are allowed. In this case, each union part must
refer at the same array identifier, and the number of dimensions must be
consistent.
</p>
<hr>
<span id="Generics"></span><div class="header">
<p>
Previous: <a href="#Relations" accesskey="p" rel="prev">Relations</a>, Up: <a href="#OpenScop-File-Format-Specification" accesskey="u" rel="up">OpenScop File Format Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Generics-1"></span><h4 class="subsection">3.2.2 Generics</h4>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Strings-Generic" accesskey="1">Strings Generic</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Body-Generic" accesskey="2">Body Generic</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><em>Generics</em> represent any elaborated non-polyhedral information in the
OpenScop format. They are used to represent the parameter information, the
statement body information as well as the extensions. Each generic information
is delimited using XML-like tags corresponding to its URI (Unique Resource
Identifier), For instance, if the generic has the URI <code>foo</code>, the begin
tag is <code>&lt;foo&gt;</code> and the end tag is <code>&lt;/foo&gt;</code>).
</p>
<p>Two generics, namely <code>strings</code> (see <a href="#Strings-Generic">Strings Generic</a>) and
<code>body</code> (see <a href="#Body-Generic">Body Generic</a>) are part of the OpenScop
specification to provide the minimum, stricly necessary information to
build a complete source-to-source polyhedral framework based on OpenScop.
However, generics can be basically <em>anything</em> as long as they are
properly delimited. OpenScop implementations will simply ignore
non-supported generics and warn the user with the mention of the
non-supported URIs. Support of new generics will be added throught the
extension mechanism.
</p>

<hr>
<span id="Strings-Generic"></span><div class="header">
<p>
Next: <a href="#Body-Generic" accesskey="n" rel="next">Body Generic</a>, Up: <a href="#Generics" accesskey="u" rel="up">Generics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Strings-Generic-1"></span><h4 class="subsubsection">3.2.2.1 Strings Generic</h4>

<p>The purpose of the <code>strings</code> generic is to represent a list of
textual strings on one line (which may be used, e.g., to represent the list of
parameter names in the order used in the relation). Its URI is <code>strings</code>
and its file format respects the following grammar:
</p><div class="example">
<pre class="example">Strings_generic     ::= &quot;&lt;strings&gt;&quot; Strings &quot;&lt;/strings&gt;&quot;
Strings             ::= _String String_list  | (void)
</pre></div>

<p>A possible example of textual <code>strings</code> is the following:
</p><div class="example">
<pre class="example">&lt;strings&gt;
Not one sentence but 6 strings!
&lt;/strings&gt;
</pre></div>


<hr>
<span id="Body-Generic"></span><div class="header">
<p>
Previous: <a href="#Strings-Generic" accesskey="p" rel="prev">Strings Generic</a>, Up: <a href="#Generics" accesskey="u" rel="up">Generics</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Body-Generic-1"></span><h4 class="subsubsection">3.2.2.2 Body Generic</h4>

<p>The purpose of the <code>body</code> generic is to represent the textual
information about a statement. It contains the number of original iterators on
the first line, the list of original iterators on the second
line (the loop counters of the statement surrounding loops in the original
program) and the original textual body expression on the third line.
Its URI is <code>body</code> and its file format respects the following grammar
(the <code>String</code> rule is reused, see <a href="#Strings-Generic">Strings Generic</a>):
</p><div class="example">
<pre class="example">Body_generic        ::= &quot;&lt;body&gt;&quot; Body &quot;&lt;/body&gt;&quot;
Body                ::= Nb_iterators Iterator_list Expression
Nb_iterators        ::= _Integer
Iterator_list       ::= Strings
Expression          ::= Strings
</pre></div>

<p>A possible example of textual <code>body</code> is the following:
</p><div class="example">
<pre class="example">&lt;body&gt;
# Number of original iterators
2
# Original iterators
i j
# Original statement expression
A[i+j] += B[i] * C[j];
&lt;/body&gt;
</pre></div>


<hr>
<span id="OpenScop-Data-Structure-Specification"></span><div class="header">
<p>
Next: <a href="#Extensions" accesskey="n" rel="next">Extensions</a>, Previous: <a href="#OpenScop-File-Format-Specification" accesskey="p" rel="prev">OpenScop File Format Specification</a>, Up: <a href="#OpenScop-Specification" accesskey="u" rel="up">OpenScop Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="OpenScop-Data-Structure-Specification-1"></span><h3 class="section">3.3 OpenScop Data Structure Specification</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#osl_005fint_005ft" accesskey="1">osl_int_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005frelation_005ft" accesskey="2">osl_relation_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005frelation_005flist_005ft" accesskey="3">osl_relation_list_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005finterface_005ft" accesskey="4">osl_interface_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005fgeneric_005ft" accesskey="5">osl_generic_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005fstrings_005ft" accesskey="6">osl_strings_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005fbody_005ft" accesskey="7">osl_body_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005fstatement_005ft" accesskey="8">osl_statement_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#osl_005fscop_005ft" accesskey="9">osl_scop_t</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>The OpenScop specification offers a small set of C data structures devoted to
represent a SCoP in memory in a convenient way. Using them in some tool or
library may greatly facilitate its interaction with other tools or libraries
which rely on this representation as well. Every field may not be useful for
a given tool or library. A general rule for all the data structure is
that a <code>NULL</code> pointer or a -1 integer value means the information is
not present. Contrary to engineering time, memory is cheap today, so it&rsquo;s much
probably not a big deal that some fields are left empty. Every field may not
be enough for a given tool or library. In this case it is much recommended
to provide a new extension which may be reused by other users
(see <a href="#Extensions">Extensions</a>).
</p>
<p>Each tool or library may have its own implementation of the OpenScop
data structures. The type names should not be the same as those provided
as an example here (they correspond to the OpenScop Library implementation).
The names of the fields, and their ordering, should however be the same. In this
way, the interaction between tools and libraries should be as simple as a cast.
</p>
<p>Before reading at the OpenScop data structures, it is much recommended to
read at the OpenScop file format description, as it is quite close to this
representation (see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>).
</p>

<hr>
<span id="osl_005fint_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005frelation_005ft" accesskey="n" rel="next">osl_relation_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fint_005ft-1"></span><h4 class="subsection">3.3.1 osl_int_t</h4>

<div class="example">
<pre class="example">union osl_int {
  long int  sp;               /* Single precision int */
  long long dp;               /* Double precision int */
  void*     mp;               /* Pointer to a multiple precision int */
};
typedef union osl_int  osl_int_t;
typedef union osl_int* osl_int_p;
</pre></div>

<p>The <code>osl_int_t</code> union stores an integer element. The
union is used to implement the multiple precision support of OpenScop.
A given implementation may or may not support a given precision type.
However, dedicated functions or macros must tell the user whether a given
precision type is supported or not. The <code>mp</code> field is a pointer to
a multiple precision int, e.g., a <code>mpz_t</code> from the GNU GMP library.
</p>

<hr>
<span id="osl_005frelation_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005frelation_005flist_005ft" accesskey="n" rel="next">osl_relation_list_t</a>, Previous: <a href="#osl_005fint_005ft" accesskey="p" rel="prev">osl_int_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005frelation_005ft-1"></span><h4 class="subsection">3.3.2 osl_relation_t</h4>

<div class="example">
<pre class="example">struct osl_relation {
  int type;                   /* What this relation is encoding */ 
  int precision;              /* Precision of the matrix elements */ 
  int nb_rows;                /* Number of rows */
  int nb_columns;             /* Number of columns */
  int nb_output_dims;         /* Number of output dimensions */
  int nb_input_dims;          /* Number of input dimensions */
  int nb_local_dims;          /* Number of local dimensions */
  int nb_parameters;          /* Number of parameters */
  osl_int_t** m;              /* Matrix of constraints */
  void* usr;                  /* User-managed field */
  struct osl_relation*  next; /* Next relation in the union */
};
typedef struct osl_relation  osl_relation_t;
typedef struct osl_relation* osl_relation_p;
</pre></div>

<p>The <code>osl_relation_t</code> structure stores a part of an
union of relations. A union of relation is a <code>NULL</code>-terminated
linked list of union parts (<code>next</code> field). The <code>type</code> field
may provide some information about what the relation is encoding:
</p><ul>
<li> -1: undefined (<code>OSL_UNDEFINED</code>),
</li><li> 2: context domain (<code>OSL_TYPE_CONTEXT</code>),
</li><li> 3: iteration domain (<code>OSL_TYPE_DOMAIN</code>),
</li><li> 4: scattering relation (<code>OSL_TYPE_SCATTERING</code>),
</li><li> 6: read access relation (<code>OSL_TYPE_READ</code>),
</li><li> 7: write access relation (<code>OSL_TYPE_WRITE</code>),
</li><li> 8: may write access relation (<code>OSL_TYPE_MAY_WRITE</code>),
</li></ul>
<p>The various numbers provide the details on the relation itself
(see <a href="#Relations">Relations</a>) while the <code>m</code> field points to
the constraint matrix. The precision of the constraint matrix elements is
provided by the <code>precision</code> field. It can take the following
values:
</p><ul>
<li> 32: 32 bits precision, elements are <code>long int</code>
      (<code>OSL_PRECISION_SP</code>),
</li><li> 64: 64 bits precision, elements are <code>long long int</code>
      (<code>OSL_PRECISION_DP</code>),
</li><li> 0: multiple precision, elements are GNU GMP Library&rsquo;s
      <code>mpz_t</code> (<code>OSL_PRECISION_MP</code>).
</li></ul>
<p>Finally, the <code>usr</code> field is provided for user&rsquo;s convenience.
</p>

<hr>
<span id="osl_005frelation_005flist_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005finterface_005ft" accesskey="n" rel="next">osl_interface_t</a>, Previous: <a href="#osl_005frelation_005ft" accesskey="p" rel="prev">osl_relation_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005frelation_005flist_005ft-1"></span><h4 class="subsection">3.3.3 osl_relation_list_t</h4>

<div class="example">
<pre class="example">struct osl_relation_list {
  osl_relation_p elt;             /* Element of the list */
  struct osl_relation_list* next; /* Next element of the list */
};
typedef struct osl_relation_list  osl_relation_list_t;
typedef struct osl_relation_list* osl_relation_list_p;
</pre></div>

<p>The <code>osl_relation_list_t</code> structure is a <code>NULL</code>-terminated
linked list of <code>osl_relation_t</code> data structures.
<code>elt</code> is a relation element of the list and <code>next</code> is the pointer to
the next element of the list.
</p>

<hr>
<span id="osl_005finterface_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005fgeneric_005ft" accesskey="n" rel="next">osl_generic_t</a>, Previous: <a href="#osl_005frelation_005flist_005ft" accesskey="p" rel="prev">osl_relation_list_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005finterface_005ft-1"></span><h4 class="subsection">3.3.4 osl_interface_t</h4>

<div class="example">
<pre class="example">typedef void  (*osl_idump_f) (FILE*, void*, int);
typedef char* (*osl_sprint_f)(void*);
typedef void* (*osl_sread_f) (char*);
typedef void* (*osl_malloc_f)();
typedef void  (*osl_free_f)  (void*);
typedef void* (*osl_clone_f) (void*);
typedef int   (*osl_equal_f) (void*, void*);

struct osl_interface {
  char* URI;                  /* Unique interface identifier string */
  osl_idump_f  idump;         /* Pointer to the idump function */
  osl_sprint_f sprint;        /* Pointer to the sprint function */
  osl_sread_f  sread;         /* Pointer to the sread function */
  osl_malloc_f malloc;        /* Pointer to the malloc function */
  osl_free_f   free;          /* Pointer to the free function */
  osl_clone_f  clone;         /* Pointer to the clone function */
  osl_equal_f  equal;         /* Pointer to the equal function */
  struct osl_interface* next; /* Next interface in the list */
};
typedef struct osl_interface  osl_interface_t;
typedef struct osl_interface* osl_interface_p;
</pre></div>

<p>The <code>osl_interface_t</code> structure represents a
node in a <code>NULL</code>-terminated list of interfaces. Each node stores the
<em>interface</em> of a generic OpenScop object, i.e., its unique name
(<code>URI</code>) and the function pointers to all the base functions it has
to provide. Extension providers will find information relative to those
functions in the OpenScop Library description (see <a href="#Base-Functions">Base Functions</a>)
and the section dedicated to writing extensions
(see <a href="#Extension-Development">Extension Development</a>).
</p>

<hr>
<span id="osl_005fgeneric_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005fstrings_005ft" accesskey="n" rel="next">osl_strings_t</a>, Previous: <a href="#osl_005finterface_005ft" accesskey="p" rel="prev">osl_interface_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fgeneric_005ft-1"></span><h4 class="subsection">3.3.5 osl_generic_t</h4>

<div class="example">
<pre class="example">struct osl_generic {
  void* data;                 /* Pointer to some data */
  osl_interface_p interface;  /* Interface to work with the data */
  struct osl_generic* next;   /* Pointer to the next generic */
};
typedef struct osl_generic  osl_generic_t;
typedef struct osl_generic* osl_generic_p;
</pre></div>

<p>The <code>osl_generic_t</code> structure represents a node in a
<code>NULL</code>-terminated list of generic elements. It stores some data
and operations with no pre-defined type. The information is accessible
through the <code>data</code> pointer while the type and operations are
accessible through the <code>interface</code> pointer. It is used to represent
data that are allowed to differ in implementations, such as symbols and
extensions.
</p>

<hr>
<span id="osl_005fstrings_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005fbody_005ft" accesskey="n" rel="next">osl_body_t</a>, Previous: <a href="#osl_005fgeneric_005ft" accesskey="p" rel="prev">osl_generic_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fstrings_005ft-1"></span><h4 class="subsection">3.3.6 osl_strings_t</h4>

<div class="example">
<pre class="example">struct osl_string {
  char** string;              /* NULL-terminated array of strings */
};
typedef struct osl_strings  osl_strings_t;
typedef struct osl_strings* osl_strings_p;
</pre></div>

<p>The <code>osl_strings_t</code> structure represents a NULL-terminated
list of C character strings. It is encapsulated into a structure to allow
its manipulation through a generic type.
</p>

<hr>
<span id="osl_005fbody_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005fstatement_005ft" accesskey="n" rel="next">osl_statement_t</a>, Previous: <a href="#osl_005fstrings_005ft" accesskey="p" rel="prev">osl_strings_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fbody_005ft-1"></span><h4 class="subsection">3.3.7 osl_body_t</h4>

<div class="example">
<pre class="example">struct osl_body {
  osl_strings_p iterators;    /* Original iterators */
  osl_strings_p expression;   /* Original statement expression */
};
typedef struct osl_body  osl_body_t;
typedef struct osl_body* osl_body_p;
</pre></div>

<p>The <code>osl_body_t</code> structure stores a statement body in a
textual form. The complete original expression (directly copy-pasted
from the original code) is in the expression field while the textual forms
of the original iterators are in the iterators field. They may be used for
substitutions inside the expression.
</p>

<hr>
<span id="osl_005fstatement_005ft"></span><div class="header">
<p>
Next: <a href="#osl_005fscop_005ft" accesskey="n" rel="next">osl_scop_t</a>, Previous: <a href="#osl_005fbody_005ft" accesskey="p" rel="prev">osl_body_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fstatement_005ft-1"></span><h4 class="subsection">3.3.8 osl_statement_t</h4>

<div class="example">
<pre class="example">struct osl_statement {
  osl_relation_p domain;      /* Iteration domain */
  osl_relation_p scattering;  /* Scattering relation */
  osl_relation_list_p access; /* List of array access relations */
  osl_generic_p extension;    /* Generic extensions */
  void* usr;                  /* A user-defined field */
  struct osl_statement* next; /* Next statement in the list */
};
typedef struct osl_statement  osl_statement_t;
typedef struct osl_statement* osl_statement_p;
</pre></div>

<p>The <code>osl_statement_t</code> structure represents a node
in a <code>NULL</code>-terminated linked list of statements. Each node contains the
useful information for a given statement to process it within a polyhedral
framework. The order in the list may matter for naming conventions
(e.g. &quot;S1&quot; for the first statement in the list). The iteration domain
and the scattering are represented using an <code>osl_relation_p</code>
structure while the accesses are using a list of
relations: one for each memory access in the statement.
The extensions part is a list of generics <code>osl_generic_t</code> which can
contain useful structures such as <code>body</code>.
The <code>body</code> field should provide information about the statement body
(since it has a generic type, the specification is not strict about how it
is used), e.g., using the <code>osl_body_t</code> data structure (see <a href="#osl_005fbody_005ft">osl_body_t</a>).
It is also possible to use the <code>usr</code> field, but it has to be
totally managed by the user.
</p>

<hr>
<span id="osl_005fscop_005ft"></span><div class="header">
<p>
Previous: <a href="#osl_005fstatement_005ft" accesskey="p" rel="prev">osl_statement_t</a>, Up: <a href="#OpenScop-Data-Structure-Specification" accesskey="u" rel="up">OpenScop Data Structure Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="osl_005fscop_005ft-1"></span><h4 class="subsection">3.3.9 osl_scop_t</h4>
<div class="example">
<pre class="example">struct osl_scop {
  int version;                /* Version of the data structure */
  char* language;             /* Target language */
  osl_relation_p context;     /* Constraints on the parameters */
  osl_generic_p parameters;   /* Information about parameters */
  osl_statement_p statement;  /* Statement list */
  osl_interface_p registry;   /* Registered extension interfaces */
  osl_generic_p extension;    /* Extension list */
  void* usr;                  /* A user-defined field */
  struct osl_scop* next;      /* Next scop in the list */
};
typedef struct osl_scop  osl_scop_t;
typedef struct osl_scop* osl_scop_p;
</pre></div>

<p><code>osl_scop_t</code> represents a node in a
<code>NULL</code>-terminated list of scops. It stores the useful informations
of a static control part of a program to process it within a polyhedral
framework. To prepare OpenScop specification evolution, the <code>version</code>
field tells the version of the data structure. It should be set to 1 for
now (and hopefully a very, very, long time).
First, it contains the informations about the context. The target language
in expressed in the <code>language</code> field. The constraints on the
global parameters are detailed in the <code>context</code> field.
The <code>paremeters</code> field should provide information about the
parameters (since it has a generic type, the specification is not strict
about how it is used), e.g., using the <code>osl_strings_t</code> data structure
(see <a href="#osl_005fstrings_005ft">osl_strings_t</a>).
Finally, it contains the list of statements <code>statement</code>, the list
of registered interfaces for generic types <code>registry</code> and the list of
extentions <code>extension</code>.
It is also possible to use the <code>usr</code> field, but it has to be
totally managed by the user.
</p>
<p>As an example, let us consider again the matrix multiply program
(see <a href="#Preliminary-Example">Preliminary Example</a>).
The next figure gives a possible representation in memory for this
SCoP thanks to the OpenScop data structures (it has been actually printed
by the <code>osl_scop_dump</code> function), note that symbols like
parameters, original iterators and statement expression are represented
with an <code>osl_strings_t</code> which does not belong to the
specification but to the OpenScop Library implementation:
</p>
<div class="example">
<pre class="example">+-- osl_scop_t
|    |    
|    Version: 1
|    |    
|    Language: C
|    |    
|    +-- osl_relation_t (CONTEXT, 32 bits)
|    |    1 3 0 0 0 1
|    |    [   1   1  -1 ]
|    |    
|    +-- osl_generic_t
|    |    |    
|    |    +-- osl_interface_t: URI = strings
|    |    |    
|    |    +-- osl_strings_t: N
|    |    |    
|    |    
|    +-- osl_statement_t (S1)
|    |    |    
|    |    +-- osl_relation_t (DOMAIN, 32 bits)
|    |    |    4 5 2 0 0 1
|    |    |    [   1   1   0   0   0 ]
|    |    |    [   1  -1   0   1  -1 ]
|    |    |    [   1   0   1   0   0 ]
|    |    |    [   1   0  -1   1  -1 ]
|    |    |    
|    |    +-- osl_relation_t (SCATTERING, 32 bits)
|    |    |    5 10 5 2 0 1
|    |    |    [   0  -1   0   0   0   0   0   0   0   0 ]
|    |    |    [   0   0  -1   0   0   0   1   0   0   0 ]
|    |    |    [   0   0   0  -1   0   0   0   0   0   0 ]
|    |    |    [   0   0   0   0  -1   0   0   1   0   0 ]
|    |    |    [   0   0   0   0   0  -1   0   0   0   0 ]
|    |    |    
|    |    +-- osl_relation_list_t
|    |    |    |    
|    |    |    +-- osl_relation_t (WRITE, 32 bits)
|    |    |    |    3 8 3 2 0 1
|    |    |    |    [   0  -1   0   0   0   0   0   1 ]
|    |    |    |    [   0   0  -1   0   1   0   0   0 ]
|    |    |    |    [   0   0   0  -1   0   1   0   0 ]
|    |    |    |    
|    |    |    
|    |    +-- osl_generic_t
|    |    |    |    
|    |    |    +-- osl_interface_t: URI = body
|    |    |    |    
|    |    |    +-- osl_strings_t: i j
|    |    |    |    
|    |    |    +-- osl_strings_t: C[i][j] = 0.0;
|    |    |    |    
|    |    |    
|    |    V
|    |  osl_statement_t (S2)
|    |    |    
|    |    +-- osl_relation_t (DOMAIN, 32 bits)
|    |    |    6 6 3 0 0 1
|    |    |    [   1   1   0   0   0   0 ]
|    |    |    [   1  -1   0   0   1  -1 ]
|    |    |    [   1   0   1   0   0   0 ]
|    |    |    [   1   0  -1   0   1  -1 ]
|    |    |    [   1   0   0   1   0   0 ]
|    |    |    [   1   0   0  -1   1  -1 ]
|    |    |    
|    |    +-- osl_relation_t (SCATTERING, 32 bits)
|    |    |    7 13 7 3 0 1
|    |    |    [   0  -1   0   0   0   0   0   0   0   0   0   0   0 ]
|    |    |    [   0   0  -1   0   0   0   0   0   1   0   0   0   0 ]
|    |    |    [   0   0   0  -1   0   0   0   0   0   0   0   0   0 ]
|    |    |    [   0   0   0   0  -1   0   0   0   0   1   0   0   0 ]
|    |    |    [   0   0   0   0   0  -1   0   0   0   0   0   0   1 ]
|    |    |    [   0   0   0   0   0   0  -1   0   0   0   1   0   0 ]
|    |    |    [   0   0   0   0   0   0   0  -1   0   0   0   0   0 ]
|    |    |    
|    |    +-- osl_relation_list_t
|    |    |    |    
|    |    |    +-- osl_relation_t (WRITE, 32 bits)
|    |    |    |    3 9 3 3 0 1
|    |    |    |    [   0  -1   0   0   0   0   0   0   1 ]
|    |    |    |    [   0   0  -1   0   1   0   0   0   0 ]
|    |    |    |    [   0   0   0  -1   0   1   0   0   0 ]
|    |    |    |    
|    |    |    V
|    |    |  osl_relation_list_t
|    |    |    |    
|    |    |    +-- osl_relation_t (READ, 32 bits)
|    |    |    |    3 9 3 3 0 1
|    |    |    |    [   0  -1   0   0   0   0   0   0   1 ]
|    |    |    |    [   0   0  -1   0   1   0   0   0   0 ]
|    |    |    |    [   0   0   0  -1   0   1   0   0   0 ]
|    |    |    |    
|    |    |    V
|    |    |  osl_relation_list_t
|    |    |    |    
|    |    |    +-- osl_relation_t (READ, 32 bits)
|    |    |    |    3 9 3 3 0 1
|    |    |    |    [   0  -1   0   0   0   0   0   0   2 ]
|    |    |    |    [   0   0  -1   0   1   0   0   0   0 ]
|    |    |    |    [   0   0   0  -1   0   0   1   0   0 ]
|    |    |    |    
|    |    |    V
|    |    |  osl_relation_list_t
|    |    |    |    
|    |    |    +-- osl_relation_t (READ, 32 bits)
|    |    |    |    3 9 3 3 0 1
|    |    |    |    [   0  -1   0   0   0   0   0   0   3 ]
|    |    |    |    [   0   0  -1   0   0   0   1   0   0 ]
|    |    |    |    [   0   0   0  -1   0   1   0   0   0 ]
|    |    |    |    
|    |    |    
|    |    +-- osl_generic_t
|    |    |    |    
|    |    |    +-- osl_interface_t: URI = body
|    |    |    |    
|    |    |    +-- osl_strings_t: i j k
|    |    |    |    
|    |    |    +-- osl_strings_t: C[i][j] = C[i][j] + A[i][k]*B[k][j];
|    |    |    |    
|    |    |    
|    |    
|    +-- NULL interface
|    |    
|    +-- NULL generic
|    |    
|    
</pre></div>


<hr>
<span id="Extensions"></span><div class="header">
<p>
Next: <a href="#History" accesskey="n" rel="next">History</a>, Previous: <a href="#OpenScop-Data-Structure-Specification" accesskey="p" rel="prev">OpenScop Data Structure Specification</a>, Up: <a href="#OpenScop-Specification" accesskey="u" rel="up">OpenScop Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Extensions-1"></span><h3 class="section">3.4 Extensions</h3>

<p>The core part of the OpenScop representation embeds what is strictly
necessary to build a complete source-to-source polyhedral framework.
However it may not be enough. Hence, OpenScop offers a very flexible
extension part. Actually, the only constraint to build an extension is
to request the OpenScop maintainer for a unique extension name: its URI
(ask the maintainer through the OpenScop mailing list
<a href="mailto:openscop-development@googlegroups.com">openscop-development@googlegroups.com</a>).
</p>
<p>The policy to support extensions is the following and is pretty simple: an
OpenScop implementation is not required to support any extension. If it
is processing an OpenScop file or data structure which contains an
extension which is not supported, it must (1) warn the user with the 
mention of the URI of the non-supported extension
and (2) ignore this extension.
</p>
<p>Extensions in an OpenScop file are provided after the core part, without
any specific order. Each extension is delimited using
XML-like tags corresponding to its URI (e.g., if the extension has the URI
<code>foo</code>, the begin tag is <code>&lt;foo&gt;</code> and the end tag is <code>&lt;/foo&gt;</code>).
There is no specification or preferred way to write the extension body.
Extensions in an OpenScop data structure must be accessible through one
pointer. This pointer will be stored in the <code>data</code> field of an
<code>osl_generic_t</code> container (see <a href="#osl_005fgeneric_005ft">osl_generic_t</a>). There must be only
one extension with the same URI in an OpenScop file or data structure.
</p>
<p>Extension writers may write a short documentation about their extension to
be added to this document. For consistency reason, this
documentation should comply to the documentation of the
<code>comment</code> option (see <a href="#Comment-Extension">Comment Extension</a>). To describe the
file format, it is allowed to reuse the existing rules and terminals
present in the OpenScop file format description without defining them
(see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>). By sending a
documentation, you accept it to be added to this document. In
particular, the sender fully accepts the license and copyright notice.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Comment-Extension" accesskey="1">Comment Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Arrays-Extension" accesskey="2">Arrays Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Scatnames-Extension" accesskey="3">Scatnames Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Coordinates-Extension" accesskey="4">Coordinates Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Clay-Extension" accesskey="5">Clay Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extbody-Extension" accesskey="6">Extbody Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Loop-Extension" accesskey="7">Loop Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Pluto-unroll-Extension" accesskey="8">Pluto unroll Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Irregular-Extension" accesskey="9">Irregular Extension</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<span id="Comment-Extension"></span><div class="header">
<p>
Next: <a href="#Scatnames-Extension" accesskey="n" rel="next">Scatnames Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Comment-Extension-1"></span><h4 class="subsection">3.4.1 Comment Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>comment</code>.
</li><li> Author: C&eacute;dric Bastoul &lt;cedric.bastoul@u-psud.fr&gt;.
</li><li> Purpose: the <code>comment</code> extension stores a textual string.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>comment</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Comment_generic     ::= &quot;&lt;comment&gt;&quot; Comment &quot;&lt;/comment&gt;&quot;
Comment             ::= _Text
</pre></div>

<p>An example of textual <code>comment</code> extension is the following:
</p><div class="example">
<pre class="example">&lt;comment&gt;
This is a comment string.
&lt;/comment&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>comment</code> extension data structure is the following:
</p><div class="example">
<pre class="example">struct osl_comment {
  char* comment;  /* Comment message as a 0-terminated string */
};
typedef struct osl_comment  osl_comment_t;
typedef struct osl_comment* osl_comment_p;
</pre></div>



<hr>
<span id="Scatnames-Extension"></span><div class="header">
<p>
Next: <a href="#Arrays-Extension" accesskey="n" rel="next">Arrays Extension</a>, Previous: <a href="#Comment-Extension" accesskey="p" rel="prev">Comment Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Scatnames-Extension-1"></span><h4 class="subsection">3.4.2 Scatnames Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>scatnames</code>.
</li><li> Author: C&eacute;dric Bastoul &lt;cedric.bastoul@u-psud.fr&gt;.
</li><li> Purpose: the <code>scatnames</code> extension provides a list of textual
scattering dimension names.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>scatnames</code> extension file format respects the following
grammar. It reuses the <code>Strings</code> description (see <a href="#Strings-Generic">Strings Generic</a>):
</p><div class="example">
<pre class="example">Scatnames_generic   ::= &quot;&lt;scatnames&gt;&quot; Scatnames &quot;&lt;/scatnames&gt;&quot;
Scatnames           ::= Strings
</pre></div>

<p>The list of scattering dimension names is provided on one single
line. The names are separated with spaces. A possible
example of such an extension is the following:
</p>
<div class="example">
<pre class="example">&lt;scatnames&gt;
# List of scattering dimension names:
beta_0 i beta_1 j beta_2
&lt;/scatnames&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>scatnames</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_scatnames {
  osl_strings_p names;  /* List of textual scattering dimension names. */
};
typedef struct osl_scatnames  osl_scatnames_t;
typedef struct osl_scatnames* osl_scatnames_p;
</pre></div>

<p>The order of the scattering dimension names in the list corresponds
to the order of the scattering dimensions.
</p>


<hr>
<span id="Arrays-Extension"></span><div class="header">
<p>
Next: <a href="#Coordinates-Extension" accesskey="n" rel="next">Coordinates Extension</a>, Previous: <a href="#Scatnames-Extension" accesskey="p" rel="prev">Scatnames Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Arrays-Extension-1"></span><h4 class="subsection">3.4.3 Arrays Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>arrays</code>.
</li><li> Author: C&eacute;dric Bastoul &lt;cedric.bastoul@u-psud.fr&gt;.
</li><li> Purpose: the <code>arrays</code> extension provides a set of textual array
names corresponding to the array identifiers used in the access relations.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>arrays</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Arrays_generic      ::= &quot;&lt;arrays&gt;&quot; Arrays &quot;&lt;/arrays&gt;&quot;
Arrays              ::= Nb_items Item_list
Item_List           ::= Item Item_list | (void)
Item                ::= Identifier Name
Nb_items            ::= _Integer
Identifier          ::= _Integer
Name                ::= _String
</pre></div>

<p>The number of array names is provided on the first line,
then each following line contains a couple identifier-name.
For instance, the following example is a correct textual <code>arrays</code>
extension. It corresponds to the array names of the preliminary example
(see <a href="#Preliminary-Example">Preliminary Example</a>):
</p>
<div class="example">
<pre class="example">&lt;arrays&gt;
# Number of array names:
3
1 C # Identifier 1 corresponds to array name &quot;C&quot; 
3 B # Identifier 3 corresponds to array name &quot;B&quot; 
2 A # Identifier 2 corresponds to array name &quot;A&quot; 
&lt;/arrays&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>arrays</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_arrays {
  int nb_names;     /* Number of names */
  int *  id;        /* Array of nb_names identifiers */
  char** names;     /* Array of nb_names names */
};
typedef struct osl_arrays  osl_arrays_t;
typedef struct osl_arrays* osl_arrays_p;
</pre></div>

<p>Each name has a name string and an identifier: the ith name has name
string <code>names[i]</code> and identifier <code>id[i]</code>.
</p>


<hr>
<span id="Coordinates-Extension"></span><div class="header">
<p>
Next: <a href="#Clay-Extension" accesskey="n" rel="next">Clay Extension</a>, Previous: <a href="#Arrays-Extension" accesskey="p" rel="prev">Arrays Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Coordinates-Extension-1"></span><h4 class="subsection">3.4.4 Coordinates Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>coordinates</code>.
</li><li> Author: C&eacute;dric Bastoul &lt;cedric.bastoul@u-psud.fr&gt;.
</li><li> Purpose: the <code>coordinates</code> extension provides the information
about the SCoP location in the original code: the original file name/path,
the starting and ending lines of the SCoP in this file (inclusives) and
the indentation level.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>coordinates</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Coordinates_generic ::= &quot;&lt;coordinates&gt;&quot; Coordinates &quot;&lt;/coordinates&gt;&quot;
Coordinates         ::= File_name Start_line Start_column
                        End_line End_column Indentation
File_name           ::= _String
Start_line          ::= _Integer
Start_column        ::= _Integer
End_line            ::= _Integer
End_column          ::= _Integer
Indentation         ::= _Integer
</pre></div>

<p>The original file name where the SCoP has been extracted is
provided on the first line, then the starting line and column numbers of the SCoP,
then the ending line and column numbers of the SCoP, and lastly the indentation level
(the number of spaces characters each line of the SCoP starts with).
For instance, the following example is a correct textual
<code>coordinates</code> extension:
</p>
<div class="example">
<pre class="example">&lt;coordinates&gt;
# File name
./test/ax-do.c
# Starting line and column
9 3
# Ending line and column
15 4
# Indentation
2
&lt;/coordinates&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>coordinates</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_coordinates {
  char* name;   /* File name */
  int   start;  /* First line of the SCoP in the source file */
  int   end;    /* Last line of the SCoP in the source file */
  int   indent; /* Indentation */
};
typedef struct osl_coordinates  osl_coordinates_t;
typedef struct osl_coordinates* osl_coordinates_p;
</pre></div>




<hr>
<span id="Clay-Extension"></span><div class="header">
<p>
Next: <a href="#Extbody-Extension" accesskey="n" rel="next">Extbody Extension</a>, Previous: <a href="#Coordinates-Extension" accesskey="p" rel="prev">Coordinates Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Clay-Extension-1"></span><h4 class="subsection">3.4.5 Clay Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>clay</code>.
</li><li> Author: C&eacute;dric Bastoul &lt;cedric.bastoul@u-psud.fr&gt;.
</li><li> Purpose: the <code>clay</code> extension stores a Clay script.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>clay</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Clay_generic        ::= &quot;&lt;clay&gt;&quot; Clay &quot;&lt;/clay&gt;&quot;
Clay                ::= _Text
</pre></div>

<p>An example of a <code>clay</code> extension is the following:
</p><div class="example">
<pre class="example">&lt;clay&gt;
fission([2,1], 1);
stripmine([2], 32, 1);
unroll([3], 4);
&lt;/clay&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>clay</code> extension data structure is the following:
</p><div class="example">
<pre class="example">struct osl_clay {
  char* script;  /* Clay script as a 0-terminated string */
};
typedef struct osl_clay  osl_clay_t;
typedef struct osl_clay* osl_clay_p;
</pre></div>



<hr>
<span id="Extbody-Extension"></span><div class="header">
<p>
Next: <a href="#Loop-Extension" accesskey="n" rel="next">Loop Extension</a>, Previous: <a href="#Clay-Extension" accesskey="p" rel="prev">Clay Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Extbody-Extension-1"></span><h4 class="subsection">3.4.6 Extbody Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>extbody</code>.
</li><li> Author: Joel Poudroux &lt;joel.poudroux@u-psud.fr&gt;.
</li><li> Purpose: the <code>extbody</code> extension provides a list of
coordinates to locate each access easily in the body string.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>extbody</code> extension file format respects the following
grammar.  It reuses the <code>Body</code> description (see <a href="#Body-Generic">Body Generic</a>)
</p>
<div class="example">
<pre class="example">Extbody_generic   ::= &quot;&lt;extbody&gt;&quot; Extbody &quot;&lt;/extbody&gt;&quot;
Extbody           ::= Coordinate_number Coordinate_list Body
Coordinate_list   ::= Access_start Access_length Coordinate_list | (void)
Coordinate_number ::= _Integer
Access_start      ::= _Integer
Access_length     ::= _Integer
</pre></div>

<p>This extension extends the see <a href="#Body-Generic">Body Generic</a>.  The number of
accesses <code>Coordinate_number</code> must be equal to the number of access relations
in the statement. Each coordinate is associated with the corresponding access
relation in the access relation list (the order matters). It is possible that an access has
two relations in the
access relation list (when it is in read/write mode). In this case we can replace one
of the couple of coordinates with a (-1 -1). It is possible to put twice the
same coordinates, but using (-1 -1) may improve some tool efficiency (e.g., Clay would
apply twice the same processing otherwise). For each access,
<code>Access_start</code> is the index of this acces in the body string (starting from 0),
and <code>Access_length</code> is the length of the access text. For instance:
</p>
<div class="example">
<pre class="example">&lt;extbody&gt;
# Number of access
3
# Mapping start/length
 0  1   # a coordinates (read)
-1 -1   # a coordinates (write)
 6  9   # b coordinates
# Number of original iterators
0
# Statement body expression
a++ + b[i+1][j];
&lt;/extbody&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>extbody</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_extbody {
  osl_body_p body;
  int nb_access;   /**&lt; Nb of access. */
  int * start;     /**&lt; Array of nb_access start. */
  int * length;    /**&lt; Array of nb_access length. */
};
typedef struct osl_extbody  osl_extbody_t;
typedef struct osl_extbody* osl_extbody_p;
</pre></div>




<hr>
<span id="Loop-Extension"></span><div class="header">
<p>
Next: <a href="#Pluto-unroll-Extension" accesskey="n" rel="next">Pluto unroll Extension</a>, Previous: <a href="#Extbody-Extension" accesskey="p" rel="prev">Extbody Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Loop-Extension-1"></span><h4 class="subsection">3.4.7 Loop Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>loop</code>.
</li><li> Author: Taj Muhammad Khan &lt;taj.khan@inria.fr&gt;.
</li><li> Purpose: the <code>loop</code> extension provides a means to transfer 
information about loops in the original code. It starts with the number of loops
in the SCoP.
For each loop it records: the iterator name, the number of statements, the statement
identifiers, the names of private variables,
and an identifier for OpenMP pragma directive.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>coordinates</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Loop_generic            ::= &quot;&lt;loop&gt;&quot; Num_loops Loop_list &quot;&lt;/loop&gt;&quot;
Num_loops               ::= _Integer
Loop_list               ::= Loop Loop_list | (void) 
Loop                    ::= Iterator_name Nb_stmts Stmt_list 
		                        Private_variables Directive
Iterator_name           ::= _String
Nb_stmts                ::= _Integer
Stmt_list               ::= Stmt_id Stmt_list | (void)
Stmt_id                 ::= _Integer
Private_variables       ::= _String
Directive               ::= _Integer
</pre></div>


<p>With in the tags, the number of loops is provided on the first line.
Next comes a series of <code>loop</code> structures. Within each <code>loop</code>,
the first line contains the name of the iterator, next comes the number of
statements in the loop followed by their identifiers separated by spaces.
Next line contains the names of the private variables and in the end is the OpenMP
pragma directive. In case there are no private variables to be declared for a
loop, the special string &quot;(null)&quot; should replace their declaration as shown
below.
</p>
<p>For instance, the following example is a correct textual
<code>loop</code> extension containing two loops:
</p>
<div class="example">
<pre class="example">&lt;loop&gt;
# Number of loops
2
# ===========================================
# Loop number 1 
# Iterator name
t2
# Number of stmts
1
# Statement identifiers
1
# Private variables
lbv,ubv
# Directive
1
# ===========================================
# Loop number 2 
# Iterator name
t2
# Number of stmts
1
# Statement identifiers
2
# Private variables
(null)
# Directive
1
&lt;/loop&gt;
</pre></div>

<p>The pragma directive can have one of the defined values: 
<code>OSL_LOOP_DIRECTIVE_NONE</code>, <code>OSL_LOOP_DIRECTIVE_PARALLEL</code>,
<code>OSL_LOOP_DIRECTIVE_MPI</code>, or <code>OSL_LOOP_DIRECTIVE_VECTOR</code>.
</p>
<p><strong>Data Structure</strong>
</p>
<p>The <code>loop</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_loop {
  char * iter;             /* \0 terminated iterator name */
  int  nb_stmts;           /* Number of statements in the loop */
  int  *  stmt_ids;        /* Array of statement identifiers. */
  char * private_vars;     /* \0 terminated variable names */
  int  directive;          /* the OpenMP directive to implement */
  struct osl_loop * next;  /* pointer to the next element */
};
typedef struct osl_loop   osl_loop_t;
typedef struct osl_loop * osl_loop_p;
</pre></div>




<hr>
<span id="Pluto-unroll-Extension"></span><div class="header">
<p>
Next: <a href="#Irregular-Extension" accesskey="n" rel="next">Irregular Extension</a>, Previous: <a href="#Loop-Extension" accesskey="p" rel="prev">Loop Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Pluto-unroll-Extension-1"></span><h4 class="subsection">3.4.8 Pluto unroll Extension</h4>

<p><strong>Description</strong>
</p><ul>
<li> URI: <code>pluto_unroll</code>.
</li><li> Author: L&eacute;na&iuml;c Bagn&egrave;res &lt;lenaic.bagneres@inria.fr&gt;.
</li><li> Purpose: the <code>pluto_unroll</code> extension provides a means to transfer 
unroll information from Pluto in the SCoP.
Pluto saves the iterator name, if unroll-and-jam or not and the unroll factor
for several loops.
</li></ul>

<p><strong>File Format</strong>
</p>
<p>The <code>pluto_unroll</code> extension file format respects the following
grammar:
</p><div class="example">
<pre class="example">Pluto_unroll  ::= &quot;&lt;pluto_unroll&gt;&quot; Is_present Data_list &quot;&lt;/pluto_unroll&gt;&quot;
Is_present    ::= _Integer
Iterator_name ::= _String
Is_Jam        ::= _Integer
Factor        ::= _Integer
Data          ::= Iterator_name Is_Jam Factor Is_present
Data_list     ::= Data_list Data | (void)
</pre></div>


<p>With in the tags, the first line indicates if data are provided.
Next comes three lines: iteraror name, integer to know if jam or not and
the unroll factor.
Next line indicates if new data are provided, etc.
</p>
<p>For instance, the following example is a correct 
<code>pluto_unroll</code> extension containing two unrolls:
</p>
<div class="example">
<pre class="example">&lt;pluto_unroll&gt;
1
# Iterator name
t3
# Jam
1
# Factor
4
# Next
1
# Iterator name
t4
# Jam
0
# Factor
4
# Next
0
&lt;/pluto_unroll&gt;
</pre></div>

<p><strong>Data Structure</strong>
</p>
<p>The <code>pluto_unroll</code> extension data structure is the following:
</p>
<div class="example">
<pre class="example">struct osl_pluto_unroll {
  char*        iter;              /* \0 terminated iterator name */
  bool         jam;               /* true if jam, false otherwise */
  unsigned int factor;            /* unroll factor */
  struct osl_pluto_unroll * next; /* next { iter, jam, factor } */
};
typedef struct osl_pluto_unroll   osl_pluto_unroll_t;
typedef struct osl_pluto_unroll * osl_pluto_unroll_p;
</pre></div>




<hr>
<span id="Irregular-Extension"></span><div class="header">
<p>
Previous: <a href="#Pluto-unroll-Extension" accesskey="p" rel="prev">Pluto unroll Extension</a>, Up: <a href="#Extensions" accesskey="u" rel="up">Extensions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Irregular-Extension-1"></span><h4 class="subsection">3.4.9 Irregular Extension</h4>



<hr>
<span id="History"></span><div class="header">
<p>
Previous: <a href="#Extensions" accesskey="p" rel="prev">Extensions</a>, Up: <a href="#OpenScop-Specification" accesskey="u" rel="up">OpenScop Specification</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="History-1"></span><h3 class="section">3.5 History</h3>

<p>OpenScop is a follow-up of Louis-No&euml;l Pouchet et al.&rsquo;s ScopLib effort which
was itself based on C&eacute;dric Bastoul et al.&rsquo;s Clan tool. People involved in
OpenScop&rsquo;s genesis are:
</p><ul>
<li> C&eacute;dric Bastoul
</li><li> Uday Bondhugula
</li><li> Tobias Grosser
</li><li> Louis-No&euml;l Pouchet
</li><li> Sven Verdoolaege
</li></ul>


<hr>
<span id="OpenScop-Library"></span><div class="header">
<p>
Next: <a href="#References" accesskey="n" rel="next">References</a>, Previous: <a href="#OpenScop-Specification" accesskey="p" rel="prev">OpenScop Specification</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="OpenScop-Library-1"></span><h2 class="chapter">4 OpenScop Library</h2>

<p>The OpenScop Library, or OSL for short, is an example implementation of the
OpenScop specification. Its API is not part of the OpenScop specification. 
It offers basic functionalities to manipulate the OpenScop data structures
(allocate, free, copy, dump, etc.) and file format (read, print, etc.).
The OpenScop Library is <em>not</em> a polyhedral library. OpenScop is an
exchange format, and the OpenScop Library reflects this. 
</p>
<p>It is a Free Software using the 3-clause BSD License.
Programmers should feel free to use
it or copy/paste its code in any project, Open Source or not<a id="DOCF3" href="#FOOT3"><sup>3</sup></a>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Precision" accesskey="1">Precision</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Base-Functions" accesskey="2">Base Functions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Example-of-OpenScop-Library-Utilization" accesskey="3">Example of OpenScop Library Utilization</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installation" accesskey="4">Installation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Documentation" accesskey="5">Documentation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Development" accesskey="6">Development</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Precision"></span><div class="header">
<p>
Next: <a href="#Base-Functions" accesskey="n" rel="next">Base Functions</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Precision-1"></span><h3 class="section">4.1 Precision</h3>

<p>The OpenScop specification does not impose a specific type for the
constraint matrix elements. For a maximum flexibility, the OpenScop Library
offers an hybrid precision implementation. It supports 32 bits, 64 bits and
multiple precision (relying on GNU GMP) relations transparently. At relation
allocation time, users have two ways to set the precision. The first way is
to call an allocation function with a precision parameter. The second way is
to rely on the environment variable <code>OSL_PRECISION</code>.
The accepted values for this variable are <code>32</code> for 32 bits precision,
<code>64</code> for 64 bits precision and <code>0</code> for multiple precision. When this
variable is set, its value becomes the default precision for relation elements.
For instance, to ensure the OpenScop Library will use 64 bits precision
by default, the user may set: 
</p><div class="example">
<pre class="example">export OSL_PRECISION=64
</pre></div>
<p>if his shell is, e.g., bash or
</p><div class="example">
<pre class="example">setenv OSL_PRECISION 64
</pre></div>
<p>if his shell is, e.g., tcsh. The user should ad this line to
his .bashrc or .tcshrc (or whatever convenient file) to make this
setting permanent. 
</p>
<p>The OpenScop Library provides the following function to know whether or not
a given precision type is supported by the library or not:
</p><div class="example">
<pre class="example">int osl_int_is_precision_supported(int precision);
</pre></div>
<p>this function returns <code>1</code> if the precision type is
supported, <code>0</code> otherwise. Possible values for the <code>precision</code>
parameter are <code>32</code> for 32 bits (single) precision, <code>64</code> for
64 bits (double) precision and <code>0</code> for multiple precision.
</p>
<hr>
<span id="Base-Functions"></span><div class="header">
<p>
Next: <a href="#Example-of-OpenScop-Library-Utilization" accesskey="n" rel="next">Example of OpenScop Library Utilization</a>, Previous: <a href="#Precision" accesskey="p" rel="prev">Precision</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Base-Functions-1"></span><h3 class="section">4.2 Base Functions</h3>

<p>The OpenScop Library provides, for each OpenScop data structure,
a set of functions devoted to basic manipulation, conversion
from file format to data structures and from data structures to
file format. The naming convention is consistent for all data
structures. Hence, the function prototypes differ only with the
name of the data structure. In the following, we will use the
generic term of <em>structure</em> to refer at any OpenScop
data structure. For instance the
<code>osl_</code><em>structure</em><code>_malloc()</code> function is a
generic name can be instantiated to
<code>osl_relation_malloc()</code> or
<code>osl_statement_malloc()</code> etc.
</p>
<p>We present in this documentation only
the main functions. Many other utility functions are provided
to ease OpenScop format manipulation. The reader is invited to
refer at the technical documentation to learn everything about the
OpenScop Library.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Dumping" accesskey="1">Dumping</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Printing" accesskey="2">Printing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Reading" accesskey="3">Reading</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Allocating" accesskey="4">Allocating</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Deallocating" accesskey="5">Deallocating</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Cloning" accesskey="6">Cloning</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Testing" accesskey="7">Testing</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<span id="Dumping"></span><div class="header">
<p>
Next: <a href="#Printing" accesskey="n" rel="next">Printing</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Dumping_003a-osl_005fstructure_005fdump-and-idump"></span><h4 class="subsection">4.2.1 Dumping: osl_<em>structure</em>_dump and idump</h4>

<div class="example">
<pre class="example">void osl_<em>structure</em>_dump(FILE* output, osl_<em>structure</em>_p s);
void osl_<em>structure</em>_idump(FILE* output, osl_<em>structure</em>_p s, int i);
</pre></div>

<p>Each OpenScop data structure has a dumping functions
as shown above. Dumping means writing down the content of the data
structure pointed by <code>s</code> (and its fields recursively)
in a textual form to the
<code>output</code> file (the file, possibly <code>stdout</code>, has to be open
for writing). The textual form is not the OpenScop file format but
another representation closer to the internal representation in
memory and mainly intended for debugging purpose. The <code>idump</code>
function has an additional integer parameter which corresponds to
an indentation level.
</p>
<hr>
<span id="Printing"></span><div class="header">
<p>
Next: <a href="#Reading" accesskey="n" rel="next">Reading</a>, Previous: <a href="#Dumping" accesskey="p" rel="prev">Dumping</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Printing_003a-osl_005fstructure_005fprint"></span><h4 class="subsection">4.2.2 Printing: osl_<em>structure</em>_print</h4>

<div class="example">
<pre class="example">void osl_<em>structure</em>_print(FILE* output, osl_<em>structure</em>_p s);
</pre></div>

<p>Each OpenScop data structure has a pretty printing function
as shown above. It prints the content of the data
structure pointed by <code>s</code> (and its fields recursively)
according to the OpenScop file format
(see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>) to the
<code>output</code> file (the file, possibly <code>stdout</code>, has to be open
for writing).
</p>
<hr>
<span id="Reading"></span><div class="header">
<p>
Next: <a href="#Allocating" accesskey="n" rel="next">Allocating</a>, Previous: <a href="#Printing" accesskey="p" rel="prev">Printing</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Reading_003a-osl_005fstructure_005fread"></span><h4 class="subsection">4.2.3 Reading: osl_<em>structure</em>_read</h4>

<div class="example">
<pre class="example">osl_<em>structure</em>_p osl_<em>structure</em>_read(FILE* input);
</pre></div>

<p>Each OpenScop data structure has a reading function
as shown above. It reads the content of an OpenScop
data structure written according to the OpenScop file format 
(see <a href="#OpenScop-File-Format-Specification">OpenScop File Format Specification</a>) from 
the <code>input</code> file (the file, possibly <code>stdin</code>, has to be open
for reading). It returns a pointer to a freshly allocated 
<code>osl_<em>structure</em>_t</code> structure containing the
information.
</p>
<hr>
<span id="Allocating"></span><div class="header">
<p>
Next: <a href="#Deallocating" accesskey="n" rel="next">Deallocating</a>, Previous: <a href="#Reading" accesskey="p" rel="prev">Reading</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Allocating_003a-osl_005fstructure_005fmalloc"></span><h4 class="subsection">4.2.4 Allocating: osl_<em>structure</em>_malloc</h4>

<div class="example">
<pre class="example">osl_<em>structure</em>_p osl_<em>structure</em>_malloc();
</pre></div>

<p>Each OpenScop data structure has a memory allocation function
as shown above (except one see below). It allocates the memory to store
the corresponding data structure, it initializes the pointer fields to
<code>NULL</code> and the integer fields to <code>OSL_UNDEFINED</code>
(<code>-1</code>) and it returns a pointer to the allocated space.
</p>
<p>An exception to this base description is the
<code>osl_relation_malloc()</code> function which requires two
parameters: the number of rows and columns of the constraint
matrix (see <a href="#Relations">Relations</a>):
</p>
<div class="example">
<pre class="example">osl_relation_p osl_relation_malloc(int nb_rows, int nb_columns);
</pre></div>

<p>The precision of the relation elements will depend on the
<code>OSL_PRECISION</code> environment variable (see <a href="#Precision">Precision</a>) if it is set,
or the maximum available precision if it is not set. Another allocation
function is provided to explicitly set a given precision:
</p>
<div class="example">
<pre class="example">osl_relation_p osl_relation_pmalloc(int precision,
                                    int nb_rows, int nb_columns);
</pre></div>

<p>The <code>precision</code> field may take the following values:
</p><ul>
<li> <code>OSL_PRECISION_SP</code> for 32 bits precision,
</li><li> <code>OSL_PRECISION_DP</code> for 64 bits precision,
</li><li> <code>OSL_PRECISION_MP</code> for multiple precision,
</li></ul>

<hr>
<span id="Deallocating"></span><div class="header">
<p>
Next: <a href="#Cloning" accesskey="n" rel="next">Cloning</a>, Previous: <a href="#Allocating" accesskey="p" rel="prev">Allocating</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Deallocating_003a-osl_005fstructure_005ffree"></span><h4 class="subsection">4.2.5 Deallocating: osl_<em>structure</em>_free</h4>

<div class="example">
<pre class="example">void osl_<em>structure</em>_free(osl_<em>structure</em>_p s);
</pre></div>

<p>Each OpenScop data structure has a memory deallocation function
as shown above. It recursively frees the memory allocated for the
structure pointed by <code>s</code>, i.e., internal structures are also freed.
</p>
<hr>
<span id="Cloning"></span><div class="header">
<p>
Next: <a href="#Testing" accesskey="n" rel="next">Testing</a>, Previous: <a href="#Deallocating" accesskey="p" rel="prev">Deallocating</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Cloning_003a-osl_005fstructure_005fclone"></span><h4 class="subsection">4.2.6 Cloning: osl_<em>structure</em>_clone</h4>

<div class="example">
<pre class="example">osl_<em>structure</em>_p osl_<em>structure</em>_clone(osl_<em>structure</em>_p s);
</pre></div>

<p>Each OpenScop data structure has a clone function
as shown above. It recursively copies the content of the
structure pointed by <code>s</code>, i.e., internal structures are also copied.
It returns a pointer to the clone of the structure pointed by <code>s</code>.
</p>
<hr>
<span id="Testing"></span><div class="header">
<p>
Previous: <a href="#Cloning" accesskey="p" rel="prev">Cloning</a>, Up: <a href="#Base-Functions" accesskey="u" rel="up">Base Functions</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Testing_003a-osl_005fstructure_005fequal"></span><h4 class="subsection">4.2.7 Testing: osl_<em>structure</em>_equal</h4>

<div class="example">
<pre class="example">int osl_<em>structure</em>_equal(osl_<em>structure</em>_p s1, osl_<em>structure</em>_p s2);
</pre></div>

<p>Each OpenScop data structure has a testing function
as shown above. It checks whether two pointers are referring to equivalent
structures (either by pointing to the same structure or to different
structures which contain the same information). It returns 1 if the
pointed structures are equivalent, 0 otherwise. This test is
<em>content-based</em> and is intended for debugging purpose. It is not
(and will never be) able to state, e.g., that two relations with
different constraint matrices are actually representing the same relation.
</p>

<hr>
<span id="Example-of-OpenScop-Library-Utilization"></span><div class="header">
<p>
Next: <a href="#Installation" accesskey="n" rel="next">Installation</a>, Previous: <a href="#Base-Functions" accesskey="p" rel="prev">Base Functions</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Example-of-OpenScop-Library-Utilization-1"></span><h3 class="section">4.3 Example of OpenScop Library Utilization</h3>
<p>Here is a basic example showing how it is possible to use the
OpenScop Library, assuming that a standard installation has been done.
The following C program reads an OpenScop file from the standard
input and dumps the content of the data structures to the standard output.
</p>
<div class="example">
<pre class="example">/* example.c */
# include &lt;stdio.h&gt;
# include &lt;osl/osl.h&gt;

int main() {
  osl_scop_p scop;

  // Read the OpenScop file.
  scop = osl_scop_read(stdin);

  // Dump the content of the scop data structure.
  osl_scop_dump(stdout, scop);

  // Save the planet.
  osl_scop_free(scop);

  return 0;
}
</pre></div>

<p>The compilation command could be:
</p><div class="example">
<pre class="example">gcc example.c -losl -o example
</pre></div>
<p>A calling command with the input file test.scop could be:
</p><div class="example">
<pre class="example">more test.scop | ./example
</pre></div>


<hr>
<span id="Installation"></span><div class="header">
<p>
Next: <a href="#Documentation" accesskey="n" rel="next">Documentation</a>, Previous: <a href="#Example-of-OpenScop-Library-Utilization" accesskey="p" rel="prev">Example of OpenScop Library Utilization</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Installation-1"></span><h3 class="section">4.4 Installation</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#License" accesskey="1">License</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Requirements" accesskey="2">Requirements</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installation-Instructions" accesskey="3">Installation Instructions</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Optional-Features" accesskey="4">Optional Features</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Uninstallation" accesskey="5">Uninstallation</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="License"></span><div class="header">
<p>
Next: <a href="#Requirements" accesskey="n" rel="next">Requirements</a>, Up: <a href="#Installation" accesskey="u" rel="up">Installation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="License-1"></span><h4 class="subsection">4.4.1 License</h4>
<p>First of all, it would be very kind to refer the present document in any
publication that results from the use of the OpenScop specification or library,
see <a href="#Bas11">Bas11</a> (a bibtex entry is provided behind the title page of this
manual, along with the copyright notice).
The OpenScop Library is provided under the 3-clause BSD license:
</p>
<p>Copyright (C) 2011 University Paris-Sud 11 and INRIA
</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
</p><ol>
<li> Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
</li><li> Redistributions in binary form must reproduce the above copyrigh
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
</li><li> The name of the author may not be used to endorse or promote products
      derived from this software without specific prior written permission
</li></ol>

<p>THIS SOFTWARE IS PROVIDED BY THE AUTHOR &ldquo;AS IS&rdquo; AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</p>
<hr>
<span id="Requirements"></span><div class="header">
<p>
Next: <a href="#Installation-Instructions" accesskey="n" rel="next">Installation Instructions</a>, Previous: <a href="#License" accesskey="p" rel="prev">License</a>, Up: <a href="#Installation" accesskey="u" rel="up">Installation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Requirements-1"></span><h4 class="subsection">4.4.2 Requirements</h4>

<p>The OpenScop Library is a stand-alone library. For a basic use,
it does not need any additional tool or library. Anyway, to be able to
work in conjunction with other tools that manipulate multiple precision
numbers, the GNU GMP library can be used as an option.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#GMP-Library" accesskey="1">GMP Library</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<span id="GMP-Library"></span><div class="header">
<p>
Up: <a href="#Requirements" accesskey="u" rel="up">Requirements</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="GMP-Library-_0028optional_0029"></span><h4 class="subsubsection">4.4.2.1 GMP Library (optional)</h4>

<p>To be able to deal with insanely large coefficient, the user will need to
install the GNU Multiple Precision Library (GMP for short) version 4.2.2
or above<a id="DOCF4" href="#FOOT4"><sup>4</sup></a>.
The user can compile it by typing the following commands on the GMP root
directory:
</p>
<ul>
<li> <code>./configure</code>
</li><li> <code>make</code>
</li><li> And as root: <code>make install</code>
</li></ul>

<p>The GMP default installation is <code>/usr/local</code>. This directory may
not be inside the user&rsquo;s library path. To fix the problem, the user should set
</p><div class="example">
<pre class="example">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib
</pre></div>
<p>if your shell is, e.g., bash or
</p><div class="example">
<pre class="example">setenv LD_LIBRARY_PATH $LD_LIBRARY_PATH:/usr/local/lib
</pre></div>
<p>if your shell is, e.g., tcsh. Add the line to your .bashrc or .tcshrc (or
whatever convenient file) to make this change permanent. Another solution
is to ask GMP to install in the standard path by using the prefix
option of the configure script:
&lsquo;<samp>./configure --prefix=/usr</samp>&rsquo;.
</p>
<p>The OpenScop Library has to be built using the GMP library by specifying
the convenient configure script options to buid the GMP version
(see <a href="#Optional-Features">Optional Features</a>).
</p>

<hr>
<span id="Installation-Instructions"></span><div class="header">
<p>
Next: <a href="#Optional-Features" accesskey="n" rel="next">Optional Features</a>, Previous: <a href="#Requirements" accesskey="p" rel="prev">Requirements</a>, Up: <a href="#Installation" accesskey="u" rel="up">Installation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Installation-Instructions-1"></span><h4 class="subsection">4.4.3 Installation Instructions</h4>

<p>Once downloaded and unpacked
(e.g. using the &lsquo;<samp>tar -zxvf openscop-0.9.0.tar.gz</samp>&rsquo; command),
you can compile the OpenScop Library by typing the following commands
on the OpenScop Library&rsquo;s root directory:
</p>
<ul>
<li> <code>./autogen.sh</code>
</li><li> <code>./configure</code>
</li><li> <code>make</code>
</li><li> And as root: <code>make install</code>
</li></ul>

<p>The program binaries and object files can be removed from the
source code directory by typing <code>make clean</code>. To also remove the
files that the <code>configure</code> script created (so you can compile the
package for a different kind of computer) type <code>make distclean</code>.
</p>
<hr>
<span id="Optional-Features"></span><div class="header">
<p>
Next: <a href="#Uninstallation" accesskey="n" rel="next">Uninstallation</a>, Previous: <a href="#Installation-Instructions" accesskey="p" rel="prev">Installation Instructions</a>, Up: <a href="#Installation" accesskey="u" rel="up">Installation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Optional-Features-1"></span><h4 class="subsection">4.4.4 Optional Features</h4>
<p>The <code>configure</code> shell script attempts to guess correct values for
various system-dependent variables and user options used during compilation.
It uses those values to create the <code>Makefile</code>. Various user options
are provided by the OpenScop Library&rsquo;s configure script. They are summarized in the
following list and may be printed by typing <code>./configure --help</code> in the
OpenScop Library top-level directory.
</p>
<ul>
<li> By default, the installation directory is <code>/usr/local</code>:
<code>make install</code> will install the package&rsquo;s files in
<code>/usr/local/bin</code>, <code>/usr/local/lib</code> and <code>/usr/local/include</code>.
The user can specify an installation prefix other than <code>/usr/local</code> by
giving <code>configure</code> the option <code>--prefix=PATH</code>.

</li><li> By default, The OpenScop Library supports 32 bits, 64 bits and GMP if
it is installed in the standard locations. Using the <code>--with-gmp</code> option
of <code>configure</code> the user can specify that no GMP (<code>--with-gmp=no</code>),
a previously installed (<code>--with-gmp=system</code>, the default) GMP or a
build GMP (<code>--with-gmp=build</code>) GMP should be used.
In case of an installed GMP, the installation location can be specified
using the <code>--with-isl-prefix=PATH</code> and if different, the installation
of the library can be specified using the
<code>--with-isl-exec-prefix=PATH</code> options of <code>configure</code>.
In the case of a build GMP, the user can also specify the build location
using <code>--with-isl-builddir=PATH</code>.
</li></ul>

<hr>
<span id="Uninstallation"></span><div class="header">
<p>
Previous: <a href="#Optional-Features" accesskey="p" rel="prev">Optional Features</a>, Up: <a href="#Installation" accesskey="u" rel="up">Installation</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Uninstallation-1"></span><h4 class="subsection">4.4.5 Uninstallation</h4>
<p>The user can easily remove the OpenScop Library from his system
by typing (as root if necessary) from the OpenScop Library top-level
directory
<code>make uninstall</code>.
</p>
<hr>
<span id="Documentation"></span><div class="header">
<p>
Next: <a href="#Development" accesskey="n" rel="next">Development</a>, Previous: <a href="#Installation" accesskey="p" rel="prev">Installation</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Documentation-1"></span><h3 class="section">4.5 Documentation</h3>
<p>The OpenScop Library distribution provides several sources of documentation.
First, the source code itself is as documented as much as possible.
The code comments use the Doxygen technical documentation system.
The user may install
Doxygen<a id="DOCF5" href="#FOOT5"><sup>5</sup></a> to automatically
generate a technical documentation by typing <code>make doc</code> or
<code>doxygen ./autoconf/Doxyfile</code> at the OpenScop Library
top-level directory after running the configure script
(see <a href="#Installation-Instructions">Installation Instructions</a>). Doxygen will generate
documentation sources (in HTML, LaTeX and man) in the <code>doc/source</code>
directory of the OpenScop Library distribution.
</p>
<p>The Texinfo source of the present document is also provided in the <code>doc</code>
directory. The user can build it in either PDF format
(by typing <code>texi2pdf openscop.texi</code>) or HTML format
(by typing <code>makeinfo --html openscop.texi</code>, using <code>--no-split</code>
option to generate a single HTML file) or info format
(by typing <code>makeinfo openscop.texi</code>).
</p>
<hr>
<span id="Development"></span><div class="header">
<p>
Previous: <a href="#Documentation" accesskey="p" rel="prev">Documentation</a>, Up: <a href="#OpenScop-Library" accesskey="u" rel="up">OpenScop Library</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Development-1"></span><h3 class="section">4.6 Development</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Copyright-Issue" accesskey="1">Copyright Issue</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Repository" accesskey="2">Repository</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Coding-Style" accesskey="3">Coding Style</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Extension-Development" accesskey="4">Extension Development</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<span id="Copyright-Issue"></span><div class="header">
<p>
Next: <a href="#Repository" accesskey="n" rel="next">Repository</a>, Up: <a href="#Development" accesskey="u" rel="up">Development</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Copyright-Issue-1"></span><h4 class="subsection">4.6.1 Copyright Issue</h4>

<p>The OpenScop Library is an Open Source project and you should feel free to
contribute by adding functionalities (in particular extensions), correcting
bugs or improving documentation. However, for painful administrative reasons,
the copyright of the core part (everything except extensions) should not be
impacted by your work. Hence, if you are doing a significant contribution to
the main part, the OpenScop Library maintainer may ask you for an agreement
about this copyright. If you plan to do such a significant contribution, it
may be wise to discuss this issue with the maintainer first. Extensions
may include developer&rsquo;s own copyright.
</p>
<hr>
<span id="Repository"></span><div class="header">
<p>
Next: <a href="#Coding-Style" accesskey="n" rel="next">Coding Style</a>, Previous: <a href="#Copyright-Issue" accesskey="p" rel="prev">Copyright Issue</a>, Up: <a href="#Development" accesskey="u" rel="up">Development</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Repository-1"></span><h4 class="subsection">4.6.2 Repository</h4>

<p>The main repository of the OpenScop Library is
<a href="http://repo.or.cz/w/openscop.git">http://repo.or.cz/w/openscop.git</a>. Developers may ask the OpenScop Library
maintainer to open them a write access to this repository. Only the maintainer
should ever change the <code>master</code> branch. Developers should work on their
own branches. To avoid any problem developers should use the <em>fork</em>
functionality of the repository.
</p>
<hr>
<span id="Coding-Style"></span><div class="header">
<p>
Next: <a href="#Extension-Development" accesskey="n" rel="next">Extension Development</a>, Previous: <a href="#Repository" accesskey="p" rel="prev">Repository</a>, Up: <a href="#Development" accesskey="u" rel="up">Development</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Coding-Style-1"></span><h4 class="subsection">4.6.3 Coding Style</h4>

<p>The OpenScop Library is written in C using an object oriented style. Each
important data structure (e.g., <code>struct foo</code>) has its own header file
(<code>include/osl/foo.h</code>) where lies the definition of
the data structure, the two typedefs for the data structure (one for the
structure, <code>osl_foo_t</code>, and one for a pointer
to the structure, <code>osl_foo_p</code>), the prototypes of the various
functions related to this data structure, all named using the
prefix &quot;<code>osl_foo_</code>&quot;. The source code of the functions is provided in a
separated C file (<code>source/foo.c</code>).
</p>  
<p>Utility functions independent from the main data structures may be placed in
separate source files (e.g., definition in <code>include/osl/util.h</code>
and code in <code>source/util.c</code>). Tool-wide preprocessor directives are
placed in <code>include/osl/macros.h</code>, macros are prefixed with
&quot;<code>OSL_</code>&quot;.
</p>
<p>The core code itself has to be written according to the Google C++ Coding Style:
<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml</a> (for
what can apply to C), plus the naming conventions discussed above with
highest priority. The extension parts must only respect the naming convention,
but a consistent coding style is much appreciated.
</p>
<hr>
<span id="Extension-Development"></span><div class="header">
<p>
Previous: <a href="#Coding-Style" accesskey="p" rel="prev">Coding Style</a>, Up: <a href="#Development" accesskey="u" rel="up">Development</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="Extension-Development-1"></span><h4 class="subsection">4.6.4 Extension Development</h4>

<p>It&rsquo;s fairly easy to integrate a new extension to OpenScop and the OpenScop
Library. Developing a new extension is very much like adding a new &quot;object&quot;:
it requires writing a data structure for the extension data and the 7 base
functions to manage this extension. Here is how developers should proceed
to add an extension called <code>foo</code> (beware that the naming convention is
strict):
</p>
<ol>
<li> Send the name <code>foo</code> to the maintainer to ensure it is unique and
      hence can be used as an URI. The name (one single
      word, or words separated with underscores &quot;_&quot;) should be
      suggested by the extension developers to the OpenScop development
      mailing list <a href="mailto:openscop-development@googlegroups.com">openscop-development@googlegroups.com</a>). It
      should not correspond to an existing structure name
      (see <code>include/osl/osl.h</code> for the list). The
      maintainer will update <code>include/osl/osl.h</code> in the development
      version accordingly.
</li><li> Look at the <code>comment</code> extension. The <code>comment</code> extension
      (see <a href="#Comment-Extension">Comment Extension</a>) has been written to be used as a basic
      example for extension developers. Having a look at
      <code>include/osl/extensions/comment.h</code> and
      <code>source/extensions/comment.c</code> will be a great help to do it right.
</li><li> Create the extension data structure: it is necessary that the
      extension data can be accessible through only one pointer.
</li><li> Code the 7 base functions for the extension. Any extension must provide
      this set of functions (naming convention apply only if the
      extension is planed to be integrated to the OpenScop Library
      default extensions):
      <ul>
<li> <code>osl_foo_idump</code> (see <a href="#Dumping">Dumping</a>) 
      </li><li> <code>osl_foo_sprint</code> has the following prototype:
<div class="example">
<pre class="example">char * osl_<em>structure</em>_sprint(osl_<em>structure</em>_p s);
</pre></div>
<p>It corresponds to the pretty printing functions of the core
           data structures (see <a href="#Printing">Printing</a>) with the
           difference that the OpenScop textual representation is written
           to a string (returned by the function) instead of a file.
      </p></li><li> <code>osl_foo_sread</code> has the following prototype:
<div class="example">
<pre class="example">osl_<em>structure</em>_p osl_<em>structure</em>_sread(char ** string);
</pre></div>
<p>It corresponds to the reading functions of the core
           data structures (see <a href="#Reading">Reading</a>) with the
           difference that the OpenScop textual representation is read
           from a string (provided as a parameter) instead of a file.
           The address of the string to read is passed as a parameter and
           is updated to point immediately after what has been actually read.
      </p></li><li> <code>osl_foo_malloc</code> (see <a href="#Allocating">Allocating</a>) 
      </li><li> <code>osl_foo_free</code> (see <a href="#Deallocating">Deallocating</a>) 
      </li><li> <code>osl_foo_clone</code> (see <a href="#Cloning">Cloning</a>) 
      </li><li> <code>osl_foo_equal</code> (see <a href="#Testing">Testing</a>) 
      </li></ul>
</li><li> Code the other functions you need!
</li></ol>

<p>Now let us consider two scenarios.
</p>
<p>First scenario, the extension is external and is
not planned to be integrated to the OpenScop Library. In this case you are
all set. Simply generate an <code>osl_interface_t</code> for your
extension and have a look at the function
<code>osl_scop_register_extension()</code> which is devoted to register
a new extension interface to an existing <code>osl_scop_t</code>.
</p>
<p>Second scenario, the extension will integrate the set of default
OpenScop Library extensions (the best solution to share it to other
potential users). In this case, a few additional
things have to be done:
</p><ol>
<li> Create the extension header
      <code>include/osl/extensions/foo.h</code> to store the extension
      structure and function prototypes and the
      extension source file <code>source/extensions/foo.c</code> for the code
      of the functions.
</li><li> Add the documentation for the extension to the texinfo source of
      this document (in <code>doc/openscop.texi</code>), following the example
      of the <code>comment</code> documentation (see <a href="#Comment-Extension">Comment Extension</a>).
</li><li> Integrate the extension by adding the <code>extensions/foo.c</code> entry
      to the <code>libosl_la_SOURCES</code> in the <code>source/Makefile.am</code>
      file, the <code>osl/foo.h</code> entry to the
      <code>nobase_pkginclude_HEADERS</code> and add the corresponding
      <code>#include &lt;osl/extensions/foo.h&gt;</code> in the
      <code>include/scop.h.in</code> file.
</li><li> Add the new extension in the
      <code>osl_interface_get_default_registry()</code> function.
</li><li> You are done! Prepare a single commit or patch corresponding to the
      integration of the new extension and ask the maintainer to merge it
      to the master branch.
</li></ol>


<hr>
<span id="References"></span><div class="header">
<p>
Previous: <a href="#OpenScop-Library" accesskey="p" rel="prev">OpenScop Library</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<span id="References-1"></span><h2 class="chapter">5 References</h2>

<ul>
<li> <span id="Bas03a"></span>[Bas03a] C. Bastoul, P. Feautrier. Improving data locality
by chunking. CC&rsquo;12 International Conference on Compiler Construction,
LNCS 2622, pages 320-335, Warsaw, April 2003.

</li><li> <span id="Bas11"></span>[Bas11] C. Bastoul.
OpenScop: A Specification and a Library for Data Exchange in Polyhedral
Compilation Tools. Technical Report, Paris-Sud University, France, June 2011.

</li><li> <span id="Fea92"></span>[Fea92] P. Feautrier. Some efficient solutions to the affine
scheduling problem, part II: multidimensional time.
International Journal of Parallel Programming, 21(6):389&ndash;420, December 1992.

</li><li> <span id="Gri04"></span>[Gri04] M. Griebl. Automatic parallelization of loop programs
for distributed memory architectures. Habilitation Thesis. Facult&auml;t f&uuml;r
Mathematik und Informatik, Universit&auml;t Passau, 2004.
<em>http://www.infosun.fmi.uni-passau.de/cl/loopo/</em>

</li><li> <span id="Wil93"></span>[Wil93] Doran K. Wilde.
A library for doing polyhedral operations.
Technical Report 785, IRISA, Rennes, France, 1993.

</li></ul>






<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT1" href="#DOCF1">(1)</a></h3>
<p><a href="http://www.cloog.org">http://www.cloog.org</a></p>
<h5><a id="FOOT2" href="#DOCF2">(2)</a></h3>
<p><a href="http://www.lri.fr/~bastoul/development/clan/">http://www.lri.fr/~bastoul/development/clan/</a></p>
<h5><a id="FOOT3" href="#DOCF3">(3)</a></h3>
<p>Closed
source projects should consider to provide some OpenScop file input
and output, so they can be incorporated to any OpenScop-based tool chain.</p>
<h5><a id="FOOT4" href="#DOCF4">(4)</a></h3>
<p><code>http://www.swox.com/gmp</code></p>
<h5><a id="FOOT5" href="#DOCF5">(5)</a></h3>
<p><code>http://www.stack.nl/~dimitri/doxygen</code></p>
</div>
<hr>



</body>
</html>
